<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storyboard Creator</title>
    <!-- Adicionando a fonte Roobert -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" referrerpolicy="no-referrer"></script>
    <!-- Biblioteca para controle de GIFs -->
    <script src="https://cdn.jsdelivr.net/gh/buzzfeed/libgif-js@master/libgif.js"></script>
    <style>
        @font-face {
            font-family: 'Roobert';
            src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter@4.5.0/files/inter-latin-400-normal.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
        }
        @font-face {
            font-family: 'Roobert';
            src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter@4.5.0/files/inter-latin-500-normal.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
        }
        @font-face {
            font-family: 'Roobert';
            src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter@4.5.0/files/inter-latin-600-normal.woff2') format('woff2');
            font-weight: 600;
            font-style: normal;
        }
        @font-face {
            font-family: 'Roobert';
            src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter@4.5.0/files/inter-latin-700-normal.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
        }
        
        :root {
            --primary-color: #00a650; /* Localiza Green */
            /* General Theme (User Configurable) */
            --bg-color: #121212;
            /* Card Styles (User Configurable) */
            --card-bg: #282828;
            --card-border-style: 1px solid #3a3a3a; /* Default border */
            /* Description Area Styles (User Configurable) */
            --desc-bg-color: #222222;
            --desc-border-style: 1px solid #3a3a3a; /* Default border */
            /* Shot Preview Area Styles (User Configurable) */
            --preview-bg-color: #404040;
            --preview-border-style: none; /* Default no border */
            /* Layout (User Configurable) */
            --shot-aspect-ratio: 1.777777; /* Default: 16/9 */
            --shot-padding: 1rem; /* Default padding inside .shot card */
            --shot-gap: 1.5rem; /* Default gap between shots */
            --shot-title-display: flex; /* Default visibility for shot titles */
            /* Fixed Colors */
            --text-color: #EAEAEA;
            --placeholder-text: #aaa;
            --shadow: 0 4px 12px rgba(0,0,0,0.5);
            --border-color-fixed: #3a3a3a; /* Use this if border style needs a color but color isn't configurable */
            /* Movie title color (novo) */
            --movie-title-color: var(--primary-color); /* Default color for movie title */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roobert', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Header Styles */
        header {
            display: flex;
            justify-content: space-between; 
            align-items: center;
            margin-bottom: 1.5rem; 
            flex-wrap: wrap;
            gap: 1rem;
        }
        h1 {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin: 0;
        }
        .header-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: flex-end; /* Alinhar botões à direita */
            position: relative; /* Needed for dropdown */
        }
        .header-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: background-color 0.3s, filter 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }
        .header-btn.reset-btn {
            background-color: #d32f2f; /* Cor vermelha para botão de reset */
        }
        .header-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
        .header-btn:hover { filter: brightness(1.1); }
        .header-btn:disabled { /* Style for disabled save button */
            background-color: #555;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        /* Save Dropdown */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--card-bg);
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
            z-index: 100;
            border-radius: 8px;
             border: var(--card-border-style);
             right: 0; /* Align dropdown to the right */
             margin-top: 5px;
        }
        .dropdown-content button {
            color: var(--text-color);
            padding: 10px 14px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 0; /* Remove individual button radius */
        }
         .dropdown-content button:first-of-type {
             border-top-left-radius: 8px;
             border-top-right-radius: 8px;
         }
         .dropdown-content button:last-of-type {
             border-bottom-left-radius: 8px;
             border-bottom-right-radius: 8px;
         }
        .dropdown-content button:hover {
            background-color: var(--desc-bg-color);
            filter: brightness(1.1);
        }
        .dropdown-content button:disabled {
             color: #777;
             cursor: not-allowed;
             background-color: var(--card-bg);
        }
        .dropdown-content.show {
            display: block;
        }

        /* Scene & Shot Card Styles */
        .scenes-container {
            display: grid;
            gap: 2rem;
        }

        .scene {
            background: var(--card-bg);
            border: var(--card-border-style);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            position: relative;
            transition: background-color 0.3s, border 0.3s;
        }

        .shot {
            background: var(--card-bg);
            border: var(--card-border-style);
            border-radius: 8px;
            padding: var(--shot-padding);
            position: relative;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, border 0.3s, padding 0.3s, box-shadow 0.3s;
        }
        
        .shot:hover {
            box-shadow: 0 0 15px rgba(0, 166, 80, 0.5); /* Sombra verde ao passar o mouse */
            z-index: 10; /* Garante que o card destacado fique acima dos outros */
        }

        .shots-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--shot-gap);
            margin-top: 1.5rem;
        }

         /* Delete Buttons */
        .delete-scene-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #555;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-weight: bold;
            cursor: pointer;
            line-height: 24px;
            text-align: center;
            font-size: 14px;
            transition: background-color 0.2s;
            z-index: 10;
        }
        .delete-scene-btn:hover { background: #e74c3c; }

        .delete-shot-btn {
            position: absolute;
            top: calc(var(--shot-padding) / 2);
            right: calc(var(--shot-padding) / 2);
            background: #555;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
            text-align: center;
            font-size: 12px;
            transition: background-color 0.2s, top 0.3s, right 0.3s;
            z-index: 10;
        }
        .delete-shot-btn:hover { background: #e74c3c; }

         /* Title Inputs */
        .scene-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-right: 0;
        }

        .scene-title {
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-grow: 1;
        }

        .scene-title-input {
            font-size: 1.25rem;
            font-weight: 600;
            border: none;
            border-bottom: 2px solid transparent;
            background: transparent;
            color: var(--text-color);
            padding: 0.2rem;
            width: auto;
            min-width: 100px;
            font-family: inherit;
            transition: border-color 0.2s;
        }
        .scene-title-input:hover,
        .scene-title-input:focus { border-bottom-color: var(--primary-color); outline: none; }

         .shot-header {
            display: var(--shot-title-display);
            align-items: center;
            margin-bottom: 0.5rem;
            padding-right: 25px; /* Espaço para botão delete */
            /* Adicionar flex para alinhar handle e título */
            display: flex; 
            gap: 0.5rem; /* Espaço entre handle e título */
        }

        /* Novo: Handle para arrastar o Shot */
        .drag-handle {
            cursor: grab;
            padding: 0 4px;
            color: #aaa;
            font-size: 1.2rem;
            line-height: 1;
            align-self: center; /* Alinhar verticalmente */
            user-select: none; /* Prevenir seleção de texto */
        }
        .drag-handle:active {
            cursor: grabbing;
        }

        .shot-title-input {
            font-size: 0.95rem;
            font-weight: 500;
            color: #ccc;
            border: none;
            border-bottom: 1px solid transparent;
            background: transparent;
            padding: 0.1rem 0;
            width: auto;
            min-width: 50px;
            font-family: inherit;
            transition: border-color 0.2s;
            flex-grow: 1; /* Título ocupa espaço restante */
        }
        .shot-title-input:hover,
        .shot-title-input:focus { border-bottom-color: var(--primary-color); outline: none; }

        /* Novo: Estilos para feedback de arraste */
        .shot.dragging {
            opacity: 0.6;
            border: 2px dashed var(--primary-color);
            transform: scale(0.98); /* Leve redução de escala para feedback tátil */
            z-index: 100; /* Garantir que fique acima dos outros durante o arrastar */
        }

        .shot.drag-over-shot {
            position: relative; /* Para posicionar as linhas de inserção */
            outline: 2px solid var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 166, 80, 0.6); /* Brilho verde mais intenso */
            z-index: 10; /* Garantir que fique acima dos outros shots não ativos */
            transition: outline 0.15s ease-out, box-shadow 0.15s ease-out;
        }

        /* Ajuste para não ter borda dupla quando dragging e over no mesmo */
        .shot.dragging.drag-over-shot {
            border-top: none; 
        }

        /* Description Textarea */
        .scene-content {
            margin-bottom: 1.5rem;
        }

        textarea {
            width: 100%;
            padding: 0.8rem;
            border: var(--desc-border-style);
            border-radius: 8px;
            resize: none;
            font-family: inherit;
            overflow: hidden;
            line-height: 1.5;
            height: 2.4rem; /* Altura para uma linha (depende do line-height) */
            min-height: 2.4rem; /* Mínimo para uma linha */
            background-color: var(--desc-bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, border 0.3s, height 0.1s;
        }
        textarea::placeholder { color: var(--placeholder-text); }

        /* Ícone de edição para vídeos */
        .edit-video-button {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.7; /* Tornar mais visível mesmo sem hover */
            transition: opacity 0.3s, background-color 0.3s;
            z-index: 10;
        }
        
        .shot-preview:hover .edit-video-button {
            opacity: 1;
            background-color: var(--primary-color);
        }
        
        /* Garantir que os vídeos ocupem todo o espaço do container */
        .shot-preview video,
        .shot-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        /* Shot Preview Area */
        .shot-preview {
            width: 100%;
            aspect-ratio: var(--shot-aspect-ratio);
            background: var(--preview-bg-color);
            border: var(--preview-border-style);
            border-radius: 6px;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: pointer;
            color: var(--placeholder-text);
            text-align: center;
            position: relative;
            /* Dashed border only for drag-over */
            transition: border-color 0.2s, background-color 0.3s, aspect-ratio 0.3s, border 0.3s;
        }

        .shot-preview::before { /* Drag over overlay */
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border: 2px dashed transparent;
            border-radius: 6px; /* Match parent */
            pointer-events: none; /* Allow clicks through */
             transition: border-color 0.2s;
        }

        .shot-preview.drag-over::before {
            border-color: var(--primary-color);
        }

        .shot-preview svg {
            width: 40px;
            height: 40px;
            margin-bottom: 0.5rem;
            fill: var(--placeholder-text);
            pointer-events: none; /* Prevent icon interfering with clicks */
        }
         .shot-preview span {
            pointer-events: none; /* Prevent span interfering with clicks */
         }

        .shot-preview img,
        .shot-preview video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .shot-preview .hidden-input { display: none; }

        /* Add Shot Button */
        .add-shot-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s, filter 0.3s;
        }
        .add-shot-btn:hover { filter: brightness(1.1); }

        /* Settings Panel */
        #settings-panel {
            position: fixed;
            top: 0;
            right: -350px;
            width: 300px;
            height: 100%;
            background-color: var(--card-bg); /* Use card bg */
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            padding: 2rem 1.5rem;
            z-index: 1000;
            transition: right 0.4s ease-in-out, background-color 0.3s;
            overflow-y: auto;
            border-left: var(--card-border-style); /* Match card border */
        }
        #settings-panel.visible { right: 0; }
        #settings-panel h2 { color: var(--primary-color); margin-bottom: 2rem; text-align: center; }
        #settings-close-btn {
             position: absolute;
             top: 15px; right: 15px;
             background: none; border: none;
             color: #aaa; font-size: 1.8rem; cursor: pointer; line-height: 1;
        }
        #settings-close-btn:hover { color: var(--text-color); }

        .settings-group {
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color-fixed);
            padding-bottom: 1.5rem;
        }
         .settings-group:last-of-type { border-bottom: none; }

        .settings-group legend {
             font-weight: 600;
             color: var(--primary-color);
             margin-bottom: 1rem;
             width: 100%;
             border-bottom: 1px solid var(--primary-color);
             padding-bottom: 0.3rem;
        }

        .settings-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #ddd;
        }
         .settings-group .inline-label {
             display: inline-block;
             vertical-align: middle;
             color: #ddd;
             margin-left: 0.5rem;
         }

        .settings-group input[type="color"],
        .settings-group input[type="number"],
        .settings-group select,
        .settings-group input[type="checkbox"] {
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid var(--border-color-fixed);
            background-color: var(--desc-bg-color); /* Match desc bg */
            color: var(--text-color);
            font-size: 0.9rem;
        }
        .settings-group select, .settings-group input:not([type="checkbox"]):not([type="color"]) {
             width: 100%;
        }

         .settings-group input[type="checkbox"] {
            width: auto;
            vertical-align: middle;
        }

        .settings-group input[type="color"] {
            height: 40px;
            padding: 0.2rem;
            width: 50px; /* Smaller color picker */
            vertical-align: middle;
             margin-left: 10px;
        }
         .settings-group .color-setting-line label {
             display: inline-block;
             margin-bottom: 0;
         }

        .settings-group input[type="number"] {
            width: 60px; /* Fixed width for number inputs */
        }
        .settings-group .unit {
            margin-left: 0.5rem;
            color: #aaa;
        }

        /* Responsive */
        @media (max-width: 768px) {
             header {
                 flex-direction: column; /* Título acima, botões abaixo */
                 align-items: center;
             }
             .header-buttons { 
                 width: 100%; 
                 justify-content: center; 
             }
             .project-info-loose {
                 flex-direction: column;
                 align-items: center; /* Centralizar tudo */
                 text-align: center;
             }
             .project-text-loose {
                 align-items: center; /* Centralizar textos */
             }
             .project-logo-area-loose {
                 margin-top: 1rem;
             }
             /* ... Resto dos estilos responsivos ... */
        }

        /* Status Message */
        #status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #status-message.visible {
            opacity: 1;
        }

        /* Novo botão + na header da cena */
        .add-shot-btn-header {
            background-color: var(--primary-color);
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, filter 0.3s;
            margin-left: 1rem;
        }
        .add-shot-btn-header:hover { filter: brightness(1.1); }

        /* Nova Seção de Detalhes do Projeto */
        .project-details {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Alinhar itens ao topo */
            padding: 1.5rem;
            background-color: var(--card-bg); /* Usar fundo similar aos cards */
            border: var(--card-border-style);
            border-radius: 12px;
            margin-bottom: 2rem; /* Espaço antes das cenas */
            gap: 2rem;
            flex-wrap: wrap;
        }

        .project-info-text {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            flex-grow: 1;
        }

        .project-info-line {
            font-size: 1rem;
            color: #ccc;
        }

        .project-info-line span[contenteditable="true"] {
            display: inline-block; /* Necessário para min-width */
            min-width: 150px; /* Largura mínima para clicar */
            padding: 0.2rem 0.4rem;
            border-bottom: 1px dashed transparent;
            cursor: text;
            color: var(--text-color);
            transition: border-color 0.2s, background-color 0.2s;
        }
        .project-info-line span[contenteditable="true"]:hover {
            border-bottom-color: var(--primary-color);
        }
        .project-info-line span[contenteditable="true"]:focus {
            outline: none;
            background-color: var(--desc-bg-color);
            border-bottom-color: var(--primary-color);
            border-bottom-style: solid;
        }

        .project-logo-area {
             /* display: flex; justify-content: flex-end; */
             /* O flex-end agora é gerenciado pelo .project-details */
        }

        .logo-container {
            width: 150px;
            height: 75px;
            background-color: var(--preview-bg-color);
            border: 1px dashed var(--border-color-fixed);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: border-color 0.3s;
        }
        .logo-container:hover {
            border-color: var(--primary-color);
        }

        #logo-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        #logo-placeholder {
            font-size: 0.85rem;
            color: var(--placeholder-text);
            text-align: center;
            padding: 5px;
        }

        /* ... Estilos anteriores ... */

        /* Nova seção para Info do Projeto SOLTA */
        .project-info-loose {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            margin-bottom: 2rem;
            padding: 0 1rem;
            gap: 2rem;
            flex-wrap: wrap;
            position: relative; /* Para permitir posicionamento absoluto de elementos internos */
        }

        .project-text-loose {
            display: block; /* Mudando para block em vez de flex */
            position: relative; /* Para posicionamento relativo */
            flex-grow: 1;
        }
        
        /* Remover qualquer gap ou espaçamento entre componentes */
        .movie-name-container,
        .client-name-container {
            margin: 0;
            padding: 0;
            line-height: 1;
        }
        
        /* Estilizando o container do nome do filme */
        .movie-name-container {
            position: relative;
            margin-bottom: var(--project-text-gap, 0px); /* Usar margem para espaçamento */
        }
        
        /* Remove o elemento de espaçamento, pois usaremos margin-bottom diretamente */
        .title-client-spacing {
            display: none;
        }
        
        /* Garantir que os spans de texto não tenham espaçamento */
        #movie-name-loose,
        #client-name-loose {
            margin: 0;
            padding: 0.2rem 0.4rem; /* Manter apenas padding horizontal */
            line-height: 1.1; /* Reduzir line-height para mínimo funcional */
        }
        
        /* Controles em uma posição que não afete o layout dos textos */
        .style-controls {
            display: inline-flex;
            gap: 10px;
            align-items: center;
            margin-left: 10px;
            vertical-align: middle;
        }

        /* Container para o nome do filme ou cliente e controles */
        .text-with-controls {
            display: flex;
            align-items: center;
        }

        /* Estilo para controle numérico de tamanho de fonte */
        .font-size-control {
            width: 45px;
            height: 25px;
            font-size: 12px;
            text-align: center;
            border: 1px solid var(--border-color-fixed);
            border-radius: 4px;
            background: var(--desc-bg-color);
            color: var(--text-color);
        }

        /* Campo para código hexadecimal */
        .color-hex-field {
            width: 65px;
            height: 25px;
            font-size: 12px;
            text-align: center;
            border: 1px solid var(--border-color-fixed);
            border-radius: 4px;
            background: var(--desc-bg-color);
            color: var(--text-color);
        }

        /* Range slider para o espaçamento */
        .spacing-control {
            width: 80px;
            margin: 0;
            padding: 0;
            vertical-align: middle;
        }

        /* Container para ajuste de espaçamento */
        .spacing-container {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
            background: var(--desc-bg-color);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
        }

        #movie-name-loose {
            font-size: var(--movie-font-size, 2rem); /* Usando variável CSS para tamanho da fonte */
            font-weight: 600;
            color: var(--movie-title-color); /* Já usando variável para permitir alteração da cor */
            padding: 0.2rem 0.4rem;
            border-bottom: 1px dashed transparent;
            cursor: text;
            display: inline-block; /* Para aplicar padding/border */
            min-width: 150px;
            transition: border-color 0.2s, background-color 0.2s;
        }
        #movie-name-loose:hover {
            border-bottom-color: var(--primary-color);
        }
        #movie-name-loose:focus {
            outline: none;
            background-color: var(--desc-bg-color);
            border-bottom-color: var(--primary-color);
            border-bottom-style: solid;
        }

        /* Container para o nome do filme e o seletor de cor */
        .movie-name-container {
            display: flex;
            align-items: center;
            width: 100%;
        }

        /* Estilo para o seletor de cor do título do filme */
        #movie-title-color, #client-name-color {
            width: 25px;
            height: 25px;
            padding: 0;
            border: none;
            border-radius: 4px;
            background: none;
            cursor: pointer;
        }

        #client-name-loose {
            font-size: var(--client-font-size, 1rem); /* Usando variável CSS para tamanho da fonte */
            color: var(--client-name-color, #ccc); /* Usando variável CSS para cor */
            padding: 0.2rem 0.4rem;
            border-bottom: 1px dashed transparent;
            cursor: text;
            display: inline-block;
            min-width: 100px;
            transition: border-color 0.2s, background-color 0.2s;
        }
        #client-name-loose:hover {
            border-bottom-color: var(--primary-color);
        }
        #client-name-loose:focus {
            outline: none;
            background-color: var(--desc-bg-color);
            border-bottom-color: var(--primary-color);
            border-bottom-style: solid;
        }

        .project-logo-area-loose {
             /* Alinhamento à direita já tratado pelo flex do container pai */
        }

        /* Ajuste no logo-container para remover fundo/borda */
        .logo-container {
            width: 150px;
            height: auto; /* Altura automática baseada na imagem */
            min-height: 50px; /* Altura mínima para placeholder */
            background-color: transparent; /* REMOVER FUNDO */
            border: none; /* REMOVER BORDA PADRÃO */
            border-radius: 0; /* Remover borda arredondada */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: none; /* Remover transição */
        }
        .logo-container:hover {
            /* Remover efeito hover da borda */
             filter: brightness(1.1); /* Leve brilho no hover */
        }
        /* Placeholder pode precisar de ajustes */
        #logo-placeholder {
             border: 1px dashed var(--border-color-fixed); /* Adicionar borda só no placeholder */
             padding: 10px;
             width: 100%;
             height: 50px; 
             display: flex;
             align-items: center;
             justify-content: center;
        }
        #logo-image { /* Garantir que a imagem seja visível */
             display: block;
        }

        /* NEW: CSS for Trim Modal */
        #trim-modal {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 1050;
            align-items: center;
            justify-content: center;
        }

        /* Ajustes para container de GIF dentro do modal */
        #modal-gif-container {
            width: 100%;
            height: 100%;
            background-color: black;
            display: none; /* Escondido por padrão */
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #modal-gif-container img {
            max-width: 100%;
            max-height: 100%;
        }

        /* Barra de progresso do SuperGif */
        .jsgif {
            max-width: 100%; 
            max-height: 100%;
            display: flex; 
            flex-direction: column;
        }

        .jsgif canvas {
            max-width: 100%;
            max-height: 100%;
        }

        .jsgif_toolbar {
            display: none !important; /* Esconder barra padrão do SuperGif */
        }

        #trim-modal > div { /* Modal content */
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 700px;
            box-shadow: var(--shadow);
            position: relative;
            display: flex;
            flex-direction: column;
        }
        #trim-modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5rem;
            cursor: pointer;
        }
        #trim-modal h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
        }
        #modal-video-container {
            width: 100%;
            aspect-ratio: 16/9;
            background-color: black;
            margin-bottom: 15px;
            position: relative;
        }
        #modal-video-player {
            width: 100%;
            height: 100%;
            display: block;
        }
        #modal-play-pause-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: rgba(255,255,255,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #modal-timeline-controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #modal-progress-bar-container {
            width: 100%;
            height: 15px;
            background-color: var(--desc-bg-color);
            border-radius: 7px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        #modal-progress-played {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            border-radius: 7px 0 0 7px;
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
        }
        #modal-progress-trim-range {
            height: 100%;
            background-color: rgba(0, 166, 80, 0.4);
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
            border-left: 2px solid white;
            border-right: 2px solid white;
        }
        #modal-progress-marker { /* This can represent the current time marker */
            width: 4px; /* Make it a bit thicker */
            height: 100%;
            background-color: red;
            position: absolute;
            left: 0%; /* Start at 0 */
            top: 0;
            pointer-events: none;
            z-index: 2; /* Above trim range */
        }
        #modal-timeline-controls .time-display {
            font-size: 0.9rem;
            color: #ccc;
        }
        #modal-timeline-controls .controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #modal-timeline-controls .buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #modal-timeline-controls button {
            background: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #modal-timeline-controls button:hover {
            background-color: #666;
        }
        #modal-play-pause {
            background: var(--primary-color);
            width: 60px;
        }
        #modal-play-pause:hover {
             filter: brightness(1.1);
        }
        .modal-action-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        .modal-action-buttons button {
            background: #555;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-action-buttons button:hover {
            filter: brightness(1.1);
        }
        #modal-apply-btn {
            background: var(--primary-color);
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Storyboard Creator</h1>
            <div class="header-buttons">
                <button id="settingsButton" class="header-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
                    Configurações
                </button>
                <button id="resetButton" class="header-btn reset-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    Resetar
                </button>
                <div class="dropdown">
                    <button id="saveButton" class="header-btn" title="Salvar Opções">
                        <svg viewBox="0 0 24 24"><path d="M19,9h-4V3H9v6H5l7,7L19,9z M5,18v2h14v-2H5z"/></svg>
                        Salvar / Exportar
                    </button>
                    <div class="dropdown-content" id="saveDropdown">
                        <button onclick="saveAsJson(); hideDropdown();" title="Salva a estrutura e textos como .json">Salvar JSON</button>
                        <button onclick="saveToLocalStorage(); hideDropdown();" title="Salva estado atual na memória do navegador">Salvar no Navegador</button>
                        <button onclick="saveAsHTML(); hideDropdown();" title="Salva uma cópia independente do HTML com as imagens incorporadas">Salvar HTML Completo</button>
                        <button id="export-zip-btn" onclick="exportZipStatic(); hideDropdown();" title="Exporta HTML estático + mídia em um .zip">Exportar ZIP (Estático)</button>
                        <button id="export-pdf-btn" onclick="exportAsPdf(); hideDropdown();" title="Exporta storyboard como PDF (Pode demorar)">Exportar PDF</button>
                     </div>
                 </div>

                <button class="header-btn" onclick="document.getElementById('loadInput').click()" title="Carregar Storyboard (JSON ou do Navegador)">
                     <svg viewBox="0 0 24 24"><path d="M9,16h6v-6h4l-7-7l-7,7h4V16z M5,18h14v2H5V18z"/></svg>
                     Carregar
                </button>
                <input type="file" id="loadInput" accept=".json" style="display: none;" onchange="handleFileLoad(event)">

                <button class="header-btn add-scene-btn" onclick="addScene()" title="Adicionar Nova Cena">
                    <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    Nova Cena
                </button>
            </div>
        </header>

        <!-- Nova seção solta para info do projeto -->
        <div class="project-info-loose">
            <div class="project-text-loose">
                <!-- Título do filme -->
                <div class="movie-name-container">
                    <div class="text-with-controls">
                        <span id="movie-name-loose" contenteditable="true"></span>
                        <div class="style-controls">
                            <input type="color" id="movie-title-color" value="#00a650" title="Alterar cor do título">
                            <input type="text" id="movie-color-hex" class="color-hex-field" value="#00a650" title="Código da cor">
                            <input type="number" id="movie-font-size" class="font-size-control" value="32" min="12" max="72" title="Tamanho da fonte">
                        </div>
                    </div>
                </div>
                
                <!-- Elemento dedicado ao espaçamento -->
                <div class="title-client-spacing"></div>
                
                <!-- Cliente -->
                <div class="client-name-container">
                    <div class="text-with-controls">
                        <span id="client-name-loose" contenteditable="true"></span>
                        <div class="style-controls">
                            <input type="color" id="client-name-color" value="#cccccc" title="Alterar cor do cliente">
                            <input type="text" id="client-color-hex" class="color-hex-field" value="#cccccc" title="Código da cor">
                            <input type="number" id="client-font-size" class="font-size-control" value="16" min="10" max="48" title="Tamanho da fonte">
                        </div>
                    </div>
                </div>

                <!-- Controle de espaçamento -->
                <div class="spacing-container">
                    <label for="text-spacing">Espaçamento:</label>
                    <input type="range" id="text-spacing" class="spacing-control" min="0" max="50" value="0" title="Ajustar espaçamento">
                    <span id="spacing-value">0px</span>
                </div>
            </div>

            <div class="project-logo-area-loose">
                <div class="logo-container" id="logo-container" title="Clique para adicionar/alterar logo">
                    <img id="logo-image" src="" alt="Logo da Empresa" style="display: none;">
                    <span id="logo-placeholder">Adicionar Logo</span>
                    <input type="file" id="logo-input" accept="image/*" style="display: none;">
                </div>
            </div>
        </div>

        <div class="scenes-container" id="scenesContainer"></div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-panel">
         <button id="settings-close-btn" onclick="toggleSettingsPanel()" title="Fechar">&times;</button>
        <h2>Configurações</h2>

        <fieldset class="settings-group">
             <legend>Geral</legend>
             <div class="color-setting-line">
                <label for="setting-bg-color">Cor de Fundo:</label>
                <input type="color" id="setting-bg-color">
             </div>
             <div style="margin-top: 1rem;">
                 <label for="setting-font-family">Fonte Principal:</label>
                 <select id="setting-font-family">
                     <option value="Inter, sans-serif">Inter</option>
                     <option value="Arial, sans-serif">Arial</option>
                     <option value="'Times New Roman', Times, serif">Times New Roman</option>
                     <option value="Verdana, sans-serif">Verdana</option>
                     <option value="Georgia, serif">Georgia</option>
                     <option value="'Courier New', Courier, monospace">Courier New</option>
                 </select>
             </div>
             <div style="margin-top: 1rem;">
                 <label for="setting-base-font-size">Tamanho Base Fonte:</label>
                 <input type="number" id="setting-base-font-size" min="10" max="24" step="1">
                 <span class="unit">px</span>
             </div>
        </fieldset>

        <fieldset class="settings-group">
             <legend>Layout dos Shots</legend>
            <div>
                <label for="setting-aspect-ratio">Aspect Ratio (Preview):</label>
                <select id="setting-aspect-ratio">
                    <option value="1.777777">16:9</option>
                    <option value="1.333333">4:3</option>
                    <option value="1">1:1</option>
                    <option value="2.35">2.35:1</option>
                    <option value="0.5625">9:16</option>
                </select>
            </div>
             <div style="margin-top: 1rem;">
                <label for="setting-shot-gap">Espaçamento:</label>
                <input type="number" id="setting-shot-gap" min="0" max="50" step="1">
                <span class="unit">px</span>
            </div>
            <div style="margin-top: 1rem;">
                <input type="checkbox" id="setting-shot-title-visible">
                <label for="setting-shot-title-visible" class="inline-label">Mostrar Títulos dos Shots</label>
            </div>
        </fieldset>

        <fieldset class="settings-group">
            <legend>Estilo dos Cards (Cenas e Shots)</legend>
             <div>
                 <input type="checkbox" id="setting-card-borders-visible">
                 <label for="setting-card-borders-visible" class="inline-label">Mostrar Bordas dos Cards</label>
            </div>
        </fieldset>

        <fieldset class="settings-group">
             <legend>Área de Descrição (Cenas e Shots)</legend>
             <div class="color-setting-line">
                <label for="setting-desc-bg-color">Cor de Fundo:</label>
                <input type="color" id="setting-desc-bg-color">
             </div>
             <div style="margin-top: 1rem;">
                 <input type="checkbox" id="setting-desc-borders-visible">
                 <label for="setting-desc-borders-visible" class="inline-label">Mostrar Bordas</label>
            </div>
        </fieldset>

         <fieldset class="settings-group">
             <legend>Área de Preview (Shots)</legend>
             <div class="color-setting-line">
                <label for="setting-preview-bg-color">Cor de Fundo:</label>
                <input type="color" id="setting-preview-bg-color">
             </div>
            <div style="margin-top: 1rem;">
                 <input type="checkbox" id="setting-preview-borders-visible">
                 <label for="setting-preview-borders-visible" class="inline-label">Mostrar Bordas</label>
            </div>
             <div style="margin-top: 1rem;">
                 <label for="setting-shot-padding">Padding Interno:</label>
                 <input type="number" id="setting-shot-padding" min="0" max="50" step="1">
                 <span class="unit">px</span>
             </div>
        </fieldset>

    </div>

     <!-- Status Message -->
    <div id="status-message"></div>

    <!-- Video Trimming Modal -->
    <div id="trim-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 1050; align-items: center; justify-content: center;">
        <div style="background-color: var(--card-bg); padding: 20px; border-radius: 10px; width: 80%; max-width: 700px; box-shadow: var(--shadow); position: relative; display: flex; flex-direction: column;">
            <button id="trim-modal-close" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: var(--text-color); font-size: 1.5rem; cursor: pointer;">&times;</button>
            <h3 style="color: var(--primary-color); margin-bottom: 15px; text-align: center;">Editar Pontos de Entrada/Saída</h3>

            <div id="modal-video-container" style="width: 100%; aspect-ratio: 16/9; background-color: black; margin-bottom: 15px; position: relative;">
                <video id="modal-video-player" style="width: 100%; height: 100%; display: block;"></video>
                <div id="modal-play-pause-overlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; color: rgba(255,255,255,0.8); pointer-events: none; opacity: 0; transition: opacity 0.3s;">▶️</div>
            </div>

            <div id="modal-timeline-controls" style="width: 100%; display: flex; flex-direction: column; gap: 10px;">
                <div id="modal-progress-bar-container" style="width: 100%; height: 15px; background-color: var(--desc-bg-color); border-radius: 7px; cursor: pointer; position: relative; overflow: hidden;">
                    <div id="modal-progress-played" style="height: 100%; background-color: var(--primary-color); width: 0%; border-radius: 7px 0 0 7px; position: absolute; left: 0; top: 0; pointer-events: none;"></div>
                    <div id="modal-progress-trim-range" style="height: 100%; background-color: rgba(0, 166, 80, 0.4); position: absolute; left: 0; top: 0; pointer-events: none; border-left: 2px solid white; border-right: 2px solid white;"></div>
                    <div id="modal-progress-marker" style="width: 4px; height: 100%; background-color: red; position: absolute; left: 0; top: 0; pointer-events: none;"></div>
                </div>

                <div class="controls-row" style="display: flex !important; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <span id="modal-current-time" class="time-display" style="display: inline-block; min-width: 40px;">0:00</span>
                    <div class="buttons" style="display: flex !important; gap: 10px; align-items: center;">
                        <button id="modal-mark-in" title="Marcar Início (I)" style="background: #444; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">[ In</button>
                        <button id="modal-mark-out" title="Marcar Fim (O)" style="background: #444; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Out ]</button>
                        <button id="modal-play-pause" title="Play/Pause (Espaço)" style="background: var(--primary-color); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; width: 60px;">Play</button>
                    </div>
                    <span id="modal-total-duration" class="time-display" style="display: inline-block; min-width: 40px;">0:00</span>
                </div>
            </div>

            <div class="modal-action-buttons" style="display: flex !important; justify-content: flex-end; gap: 10px; margin-top: 15px;">
                <button id="modal-cancel-btn" style="background: #555; color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer;">Cancelar</button>
                <button id="modal-apply-btn" style="background: var(--primary-color); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer;">Aplicar</button>
            </div>
        </div>
    </div>

    <script>
        // Ensure jsPDF is accessible (needed for PDF export)
        let jsPDF;
        try {
            jsPDF = window.jspdf?.jsPDF;
        } catch (e) {
            console.warn("jsPDF not loaded correctly, PDF export will be disabled");
        }

        // --- Globals & Setup ---
        let sceneCounter = 1;
        const settingsPanel = document.getElementById('settings-panel');
        const scenesContainer = document.getElementById('scenesContainer');
        const root = document.documentElement;
        const exportZipBtn = document.getElementById('export-zip-btn');
        const exportPdfBtn = document.getElementById('export-pdf-btn');
        const statusMessage = document.getElementById('status-message');
        const movieNameEditableSpan = document.getElementById('movie-name-loose'); 
        const clientNameEditableSpan = document.getElementById('client-name-loose'); 
        const movieTitleColorInput = document.getElementById('movie-title-color');
        const movieColorHexInput = document.getElementById('movie-color-hex');
        const movieFontSizeInput = document.getElementById('movie-font-size');
        const clientNameColorInput = document.getElementById('client-name-color');
        const clientColorHexInput = document.getElementById('client-color-hex');
        const clientFontSizeInput = document.getElementById('client-font-size');
        const textSpacingInput = document.getElementById('text-spacing');
        const spacingValueDisplay = document.getElementById('spacing-value');
        const logoContainer = document.getElementById('logo-container'); 
        const logoImage = document.getElementById('logo-image'); 
        const logoPlaceholder = document.getElementById('logo-placeholder'); 
        const logoInput = document.getElementById('logo-input'); 
        let fileReferences = {}; 
        const LOCALSTORAGE_KEY = 'storyboardAppState'; 
        let projectInfo = { 
            movieName: 'Nome do Filme Editável', 
            clientName: 'Cliente Editável', 
            logoDataUrl: '',
            movieTitleColor: '#00a650', // Cor do título
            movieFontSize: '32', // Tamanho da fonte do título em px
            clientNameColor: '#cccccc', // Cor do cliente
            clientFontSize: '16', // Tamanho da fonte do cliente em px
            textSpacing: '8' // Espaçamento entre os textos em px
        }; 
        const projectInfoSection = document.querySelector('.project-info-loose');
        // NEW: Modal elements
        const trimModal = document.getElementById('trim-modal');
        const modalVideoPlayer = document.getElementById('modal-video-player');
        const modalCloseBtn = document.getElementById('trim-modal-close');
        const modalPlayPauseBtn = document.getElementById('modal-play-pause');
        const modalMarkInBtn = document.getElementById('modal-mark-in');
        const modalMarkOutBtn = document.getElementById('modal-mark-out');
        const modalApplyBtn = document.getElementById('modal-apply-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalCurrentTimeDisplay = document.getElementById('modal-current-time');
        const modalTotalDurationDisplay = document.getElementById('modal-total-duration');
        const modalProgressBarContainer = document.getElementById('modal-progress-bar-container');
        const modalProgressPlayed = document.getElementById('modal-progress-played');
        const modalProgressTrimRange = document.getElementById('modal-progress-trim-range');
        const modalProgressMarker = document.getElementById('modal-progress-marker');
        let currentEditingVideoElement = null; // Reference to the original video element being edited
        let modalStartTime = 0;
        let modalEndTime = 0;
        let draggedShot = null; // <<< Novo: Para rastrear o shot sendo arrastado

        // --- Settings --- 
        const defaultSettings = {
            bgColor: '#121212',
            shotTitleVisible: true,
            shotAspectRatio: '1.777777',
            shotPadding: '16',
            shotGap: '24',
            cardBordersVisible: true,
            descBgColor: '#222222',
            descBordersVisible: true,
            previewBgColor: '#404040',
            previewBordersVisible: false,
            // Novas configurações de fonte
            mainFontFamily: 'Inter, sans-serif',
            baseFontSize: '16' // <<< Adicionado (apenas o número)
        };
        let settings = { ...defaultSettings };

        // --- Adicionar a função createSceneElement que estava faltando ---
        function createSceneElement(title = `Cena ${sceneCounter}`) {
            const sceneId = Date.now() + Math.random().toString(36).substring(2, 9);
            const sceneEl = document.createElement('div');
            sceneEl.classList.add('scene');
            sceneEl.dataset.sceneId = sceneId;
            
            // Scene header
            const sceneHeader = document.createElement('div');
            sceneHeader.classList.add('scene-header');
            
            // Scene title input
            const sceneTitleContainer = document.createElement('div');
            sceneTitleContainer.classList.add('scene-title');
            
            const sceneTitleInput = document.createElement('input');
            sceneTitleInput.type = 'text';
            sceneTitleInput.classList.add('scene-title-input');
            sceneTitleInput.value = title;
            sceneTitleInput.dataset.sceneTitleInput = true;
            sceneTitleInput.oninput = () => autoSizeInput(sceneTitleInput);
            sceneTitleContainer.appendChild(sceneTitleInput);
            
            sceneHeader.appendChild(sceneTitleContainer);
            
            // Adicionar o botão "+" na header ao invés do botão grande no final
            const addShotBtn = document.createElement('button');
            addShotBtn.classList.add('add-shot-btn-header');
            addShotBtn.textContent = '+';
            addShotBtn.title = 'Adicionar Shot';
            addShotBtn.onclick = () => createShotElement(sceneEl);
            sceneHeader.appendChild(addShotBtn);
            
            sceneEl.appendChild(sceneHeader);
            
            // Delete scene button
            const deleteSceneBtn = document.createElement('button');
            deleteSceneBtn.classList.add('delete-scene-btn');
            deleteSceneBtn.textContent = '×';
            deleteSceneBtn.title = 'Remover cena';
            deleteSceneBtn.onclick = () => {
                if (confirm('Tem certeza que deseja remover esta cena e todos os seus shots?')) {
                    sceneEl.remove();
                }
            };
            sceneEl.appendChild(deleteSceneBtn);
            
            // Scene content
            const sceneContent = document.createElement('div');
            sceneContent.classList.add('scene-content');
            
            // Scene description textarea
            const sceneDesc = document.createElement('textarea');
            sceneDesc.placeholder = 'Descrição da cena...';
            sceneDesc.dataset.sceneDesc = true;
            sceneDesc.oninput = () => autoResize(sceneDesc);
            sceneContent.appendChild(sceneDesc);
            
            sceneEl.appendChild(sceneContent);
            
            // Shots container
            const shotsContainer = document.createElement('div');
            shotsContainer.classList.add('shots-container');
            sceneEl.appendChild(shotsContainer);
            
            sceneCounter++;
            setTimeout(() => autoSizeInput(sceneTitleInput), 0);
            return sceneEl;
        }

        // --- Adicionar a função createShotElement que estava faltando ---
        function createShotElement(sceneEl, title = '') {
            const shotId = Date.now() + Math.random().toString(36).substring(2, 9);
            const previewId = 'preview_' + Math.random().toString(36).substring(2, 9);
            const shotsContainer = sceneEl.querySelector('.shots-container');
            const shotCount = shotsContainer.childElementCount + 1;
            
            const shotEl = document.createElement('div');
            shotEl.classList.add('shot');
            shotEl.dataset.shotId = shotId;
            shotEl.draggable = true; // <<< Adicionar draggable ao shot inteiro
            
            // Shot header
            const shotHeader = document.createElement('div');
            shotHeader.classList.add('shot-header');
            
            // Novo: Handle para arrastar
            const dragHandle = document.createElement('span');
            dragHandle.classList.add('drag-handle');
            dragHandle.innerHTML = '&#x2630;'; // Ícone de menu (hamburger) como handle
            dragHandle.title = 'Arrastar para reordenar';
            shotHeader.appendChild(dragHandle);
            
            // Shot title
            const shotTitleInput = document.createElement('input');
            shotTitleInput.type = 'text';
            shotTitleInput.classList.add('shot-title-input');
            shotTitleInput.value = title || `Shot ${shotCount}`;
            shotTitleInput.dataset.shotTitleInput = true;
            shotTitleInput.oninput = () => autoSizeInput(shotTitleInput, 9);
            shotHeader.appendChild(shotTitleInput);
            
            shotEl.appendChild(shotHeader);
            
            // Delete shot button
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-shot-btn');
            deleteBtn.textContent = '×';
            deleteBtn.title = 'Remover shot';
            deleteBtn.onclick = () => {
                // Clean up file reference
                const previewContainer = shotEl.querySelector('.shot-preview');
                const previewId = previewContainer?.dataset.previewId;
                if (previewId && fileReferences[previewId]) {
                    delete fileReferences[previewId];
                }
                shotEl.remove();
            };
            shotEl.appendChild(deleteBtn);
            
            // Shot preview area
            const previewContainer = document.createElement('div');
            previewContainer.classList.add('shot-preview');
            previewContainer.dataset.previewId = previewId;
            previewContainer.onclick = (event) => triggerFileInput(previewContainer, event);
            previewContainer.onpaste = (event) => handlePaste(event, previewContainer);
            previewContainer.ondragover = (event) => handleDragOver(event, previewContainer);
            previewContainer.ondragleave = (event) => handleDragLeave(event, previewContainer);
            previewContainer.ondrop = (event) => handleDrop(event, previewContainer);
            
            // Preview icon (shown when no media)
            const previewIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            previewIcon.setAttribute("viewBox", "0 0 24 24");
            const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            iconPath.setAttribute("d", "M19 7v2.99s-1.99.01-2 0V7h-3s.01-1.99 0-2h3V2h2v3h3v2h-3zm-3 4V8h-3V5H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-8h-3zM5 19l3-4 2 3 3-4 4 5H5z");
            previewIcon.appendChild(iconPath);
            previewContainer.appendChild(previewIcon);
            
            // Preview text
            const previewText = document.createElement('span');
            previewText.textContent = 'Clique, arraste ou cole uma imagem/vídeo';
            previewContainer.appendChild(previewText);
            
            // Hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.className = 'hidden-input';
            fileInput.accept = 'image/*,video/*';
            fileInput.onchange = (event) => handleFileSelect(event, fileInput);
            previewContainer.appendChild(fileInput);
            
            shotEl.appendChild(previewContainer);
            
            // Shot description area
            const shotDesc = document.createElement('textarea');
            shotDesc.placeholder = 'Descrição do shot...';
            shotDesc.dataset.shotDesc = true;
            shotDesc.oninput = () => autoResize(shotDesc);
            shotEl.appendChild(shotDesc);
            
            // Adicionar eventos para reprodução no hover
            applyHoverEvents(shotEl, previewContainer); // Call hover setup here
            
            // Add to shots container
            shotsContainer.appendChild(shotEl);
            setTimeout(() => {
                autoSizeInput(shotTitleInput, 9);
                autoResize(shotDesc);
            }, 0);
            
            return shotEl;
        }

        // --- Adicionar a função addScene que estava faltando ---
        function addScene(sceneData) {
            let sceneEl;
            if (sceneData) {
                sceneEl = createSceneElement(sceneData.title);
                const sceneDescTextarea = sceneEl.querySelector('[data-scene-desc]');
                if (sceneDescTextarea && sceneData.description) {
                    sceneDescTextarea.value = sceneData.description;
                    autoResize(sceneDescTextarea);
                }
                
                // Add shots if they exist
                if (Array.isArray(sceneData.shots)) {
                    sceneData.shots.forEach(shot => {
                        const shotEl = createShotElement(sceneEl, shot.title);
                        const shotDescTextarea = shotEl.querySelector('[data-shot-desc]');
                        if (shotDescTextarea && shot.description) {
                            shotDescTextarea.value = shot.description;
                            autoResize(shotDescTextarea);
                        }
                    });
                }
            } else {
                // Create empty scene
                sceneEl = createSceneElement();
            }
            
            // Add scene to the container
            scenesContainer.appendChild(sceneEl);
            return sceneEl;
        }

        // --- Fix triggerFileInput to work with event parameter ---
        function triggerFileInput(previewContainer, event) { 
            if (event.target === previewContainer || event.target.tagName === 'SPAN' || event.target.tagName === 'svg' || event.target.tagName === 'path') { 
                previewContainer.querySelector('.hidden-input').click(); 
            } 
        }

        function loadSettingsFromState(state) {
             settings = { ...defaultSettings, ...(state.settings || {}) };
             applySettings();
             updateSettingsUI();
        }
        function applySettings() {
             root.style.setProperty('--bg-color', settings.bgColor);
             root.style.setProperty('--shot-title-display', settings.shotTitleVisible ? 'flex' : 'none');
             root.style.setProperty('--shot-aspect-ratio', settings.shotAspectRatio);
             root.style.setProperty('--shot-padding', `${settings.shotPadding}px`);
             root.style.setProperty('--shot-gap', `${settings.shotGap}px`);
             const fixedBorderColor = getComputedStyle(root).getPropertyValue('--border-color-fixed').trim() || '#3a3a3a';
             root.style.setProperty('--card-border-style', settings.cardBordersVisible ? `1px solid ${fixedBorderColor}` : 'none');
             root.style.setProperty('--desc-bg-color', settings.descBgColor);
             root.style.setProperty('--desc-border-style', settings.descBordersVisible ? `1px solid ${fixedBorderColor}` : 'none');
             root.style.setProperty('--preview-bg-color', settings.previewBgColor);
             root.style.setProperty('--preview-border-style', settings.previewBordersVisible ? `1px solid ${fixedBorderColor}` : 'none');
             
             // Aplicar novas settings de fonte
             root.style.setProperty('font-family', settings.mainFontFamily);
             root.style.setProperty('font-size', `${settings.baseFontSize}px`);

             document.querySelectorAll('.delete-shot-btn').forEach(btn => {
                 try {
                     const paddingValue = parseInt(settings.shotPadding) || 0;
                     btn.style.top = `${paddingValue / 2}px`;
                     btn.style.right = `${paddingValue / 2}px`;
                 } catch (e) {}
             });
        }
         function updateSettingsUI() {
             try {
                 document.getElementById('setting-bg-color').value = settings.bgColor;
                 document.getElementById('setting-shot-title-visible').checked = settings.shotTitleVisible;
                 document.getElementById('setting-aspect-ratio').value = settings.shotAspectRatio;
                 document.getElementById('setting-shot-padding').value = settings.shotPadding;
                 document.getElementById('setting-shot-gap').value = settings.shotGap;
                 document.getElementById('setting-card-borders-visible').checked = settings.cardBordersVisible;
                 document.getElementById('setting-desc-bg-color').value = settings.descBgColor;
                 document.getElementById('setting-desc-borders-visible').checked = settings.descBordersVisible;
                 document.getElementById('setting-preview-bg-color').value = settings.previewBgColor;
                 document.getElementById('setting-preview-borders-visible').checked = settings.previewBordersVisible;
                 
                 // Atualizar UI das novas settings
                 document.getElementById('setting-font-family').value = settings.mainFontFamily;
                 document.getElementById('setting-base-font-size').value = settings.baseFontSize;
             } catch (e) { console.error("Error updating settings UI:", e); }
        }

        // Adicionar event listeners para os inputs de configuração
        function setupSettingsListeners() {
            try {
                // Cor de fundo
                document.getElementById('setting-bg-color').addEventListener('input', function() {
                    settings.bgColor = this.value;
                    applySettings();
                });
                
                // Visibilidade dos títulos dos shots
                document.getElementById('setting-shot-title-visible').addEventListener('change', function() {
                    settings.shotTitleVisible = this.checked;
                    applySettings();
                });
                
                // Aspect ratio
                document.getElementById('setting-aspect-ratio').addEventListener('change', function() {
                    settings.shotAspectRatio = this.value;
                    applySettings();
                });
                
                // Padding dos shots
                document.getElementById('setting-shot-padding').addEventListener('input', function() {
                    settings.shotPadding = this.value;
                    applySettings();
                });
                
                // Espaçamento entre shots
                document.getElementById('setting-shot-gap').addEventListener('input', function() {
                    settings.shotGap = this.value;
                    applySettings();
                });
                
                // Bordas dos cards
                document.getElementById('setting-card-borders-visible').addEventListener('change', function() {
                    settings.cardBordersVisible = this.checked;
                    applySettings();
                });
                
                // Cor de fundo das descrições
                document.getElementById('setting-desc-bg-color').addEventListener('input', function() {
                    settings.descBgColor = this.value;
                    applySettings();
                });
                
                // Bordas das descrições
                document.getElementById('setting-desc-borders-visible').addEventListener('change', function() {
                    settings.descBordersVisible = this.checked;
                    applySettings();
                });
                
                // Cor de fundo dos previews
                document.getElementById('setting-preview-bg-color').addEventListener('input', function() {
                    settings.previewBgColor = this.value;
                    applySettings();
                });
                
                // Bordas dos previews
                document.getElementById('setting-preview-borders-visible').addEventListener('change', function() {
                    settings.previewBordersVisible = this.checked;
                    applySettings();
                });

                // Listener para Fonte Principal
                document.getElementById('setting-font-family').addEventListener('change', function() {
                    settings.mainFontFamily = this.value;
                    applySettings();
                });

                // Listener para Tamanho Base da Fonte
                document.getElementById('setting-base-font-size').addEventListener('input', function() {
                    settings.baseFontSize = this.value;
                    applySettings();
                });

            } catch (e) {
                console.error("Error setting up settings listeners:", e);
            }
        }
        
        function toggleSettingsPanel() { 
            settingsPanel.classList.toggle('visible'); 
        }

        // --- Status Message Utility ---
        let statusTimeout;
        function showStatus(message, duration = 3000) {
            clearTimeout(statusTimeout);
            statusMessage.textContent = message;
            statusMessage.classList.add('visible');
            statusTimeout = setTimeout(() => {
                statusMessage.classList.remove('visible');
            }, duration);
        }

        // --- Data Structure Generation ---
        function getStoryboardData() {
             const scenes = Array.from(scenesContainer.querySelectorAll('.scene'));
             return scenes.map(sceneEl => {
                 const title = sceneEl.querySelector('[data-scene-title-input]').value;
                 const description = sceneEl.querySelector('[data-scene-desc]').value;
                 const shotsContainerEl = sceneEl.querySelector('.shots-container');
                 const shots = Array.from(shotsContainerEl.querySelectorAll('.shot')).map(shotEl => {
                     const shotTitle = shotEl.querySelector('[data-shot-title-input]').value;
                     const shotDescription = shotEl.querySelector('[data-shot-desc]').value;
                     const previewId = shotEl.querySelector('.shot-preview')?.dataset.previewId;
                     return { title: shotTitle, description: shotDescription, previewId }; // Include previewId
                 });
                 return { title, description, shots };
             });
        }

        // --- Build Storyboard from Data ---
        function buildStoryboardFromData(scenes) {
            try {
                // Clear existing content
                scenesContainer.innerHTML = '';
                fileReferences = {}; // Reset file references
                
                // Find highest scene number for counter
                let maxSceneNum = 0;
                
                if (Array.isArray(scenes)) {
                    scenes.forEach((scene, index) => {
                        try {
                            // Create new scene element
                            const sceneEl = createSceneElement(scene.title || `Cena ${index + 1}`);
                            const sceneDescTextarea = sceneEl.querySelector('[data-scene-desc]');
                            if (sceneDescTextarea && scene.description) {
                                sceneDescTextarea.value = scene.description;
                                autoResize(sceneDescTextarea);
                            }
                            
                            // Extract scene number if present in title
                            const sceneNumMatch = /Cena\s+(\d+)/.exec(scene.title || '');
                            if (sceneNumMatch && sceneNumMatch[1]) {
                                maxSceneNum = Math.max(maxSceneNum, parseInt(sceneNumMatch[1]));
                            }
                            
                            // Add shots to this scene
                            if (Array.isArray(scene.shots)) {
                                scene.shots.forEach(shot => {
                                    try {
                                        const shotEl = createShotElement(sceneEl, shot.title);
                                        const shotDescTextarea = shotEl.querySelector('[data-shot-desc]');
                                        if (shotDescTextarea && shot.description) {
                                            shotDescTextarea.value = shot.description;
                                            autoResize(shotDescTextarea);
                                        }
                                        
                                        // Se tiver imageData (Base64) do modo anterior, usá-lo
                                        if (shot.imageData && shot.imageType) {
                                            const previewContainer = shotEl.querySelector('.shot-preview');
                                            if (previewContainer) {
                                                displayBase64Media(shot.imageData, shot.imageType, previewContainer);
                                            }
                                        }
                                        // Se tiver URL de imagem (novo modo), usá-la
                                        else if (shot.imageURL && shot.imageType) {
                                            const previewContainer = shotEl.querySelector('.shot-preview');
                                            if (previewContainer) {
                                                displayURLMedia(shot.imageURL, shot.imageType, previewContainer);
                                            }
                                        }
                                    } catch (e) {
                                        console.error("Error creating shot:", e);
                                    }
                                });
                            }
                            
                            scenesContainer.appendChild(sceneEl);
                        } catch (e) {
                            console.error("Error creating scene:", e);
                        }
                    });
                }
                
                // Update scene counter for adding new scenes
                sceneCounter = Math.max(maxSceneNum, scenes.length) + 1;
                
                // Re-apply settings
                applySettings();
            } catch (e) {
                console.error("Error building storyboard from data:", e);
                // If building fails, make sure we have at least one scene
                if (scenesContainer.children.length === 0) {
                    addScene();
                }
            }
        }
        
        // Função para exibir mídia de Base64
        function displayBase64Media(base64Data, imageType, previewContainer) {
            // Limpar o conteúdo atual
            previewContainer.innerHTML = '';
            
            // Gerar um ID para este preview
            const previewId = 'preview_' + Math.random().toString(36).substring(2, 9);
            previewContainer.dataset.previewId = previewId;
            
            // Criar um elemento hidden input
            const inputElement = document.createElement('input');
            inputElement.type = 'file';
            inputElement.className = 'hidden-input';
            inputElement.accept = 'image/*,video/*';
            inputElement.onchange = (event) => handleFileSelect(event, inputElement);
            previewContainer.appendChild(inputElement);
            
            // Se for uma URL de vídeo externo (caso especial)
            if (imageType === 'video-url') {
                const video = document.createElement('video');
                video.src = base64Data; // Neste caso, base64Data é na verdade um URL
                video.controls = true;
                previewContainer.appendChild(video);
                return;
            }
            
            // Criar o elemento de mídia apropriado (img ou video)
            if (imageType.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = base64Data;
                previewContainer.appendChild(img);
                
                // Tentar criar um File object para manter compatibilidade
                try {
                    fetch(base64Data)
                        .then(res => res.blob())
                        .then(blob => {
                            const file = new File([blob], 'saved_image.jpg', { type: imageType });
                            fileReferences[previewId] = file;
                        })
                        .catch(err => console.error("Erro ao restaurar imagem:", err));
                } catch (e) {
                    console.warn("Não foi possível criar File object da imagem:", e);
                }
            } else if (imageType.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = base64Data;
                video.controls = true;
                previewContainer.appendChild(video);
                
                // Tentar criar um File object para manter compatibilidade
                try {
                    fetch(base64Data)
                        .then(res => res.blob())
                        .then(blob => {
                            const file = new File([blob], 'saved_video.mp4', { type: imageType });
                            fileReferences[previewId] = file;
                        })
                        .catch(err => console.error("Erro ao restaurar vídeo:", err));
                } catch (e) {
                    console.warn("Não foi possível criar File object do vídeo:", e);
                }
            }
            
            // Restaurar os eventos para o container
            previewContainer.onclick = (event) => triggerFileInput(previewContainer, event);
            previewContainer.onpaste = (event) => handlePaste(event, previewContainer);
            previewContainer.ondragover = (event) => handleDragOver(event, previewContainer);
            previewContainer.ondragleave = (event) => handleDragLeave(event, previewContainer);
            previewContainer.ondrop = (event) => handleDrop(event, previewContainer);
        }

        // Adicionar função para exibir mídia a partir de URL
        function displayURLMedia(url, mediaType, previewContainer) {
            // Limpar o conteúdo atual
            previewContainer.innerHTML = '';
            
            // Gerar um ID para este preview
            const previewId = 'preview_' + Math.random().toString(36).substring(2, 9);
            previewContainer.dataset.previewId = previewId;
            
            // Criar um elemento hidden input para manter funcionalidade
            const inputElement = document.createElement('input');
            inputElement.type = 'file';
            inputElement.className = 'hidden-input';
            inputElement.accept = 'image/*,video/*';
            inputElement.onchange = (event) => handleFileSelect(event, inputElement);
            previewContainer.appendChild(inputElement);
            
            // Criar o elemento apropriado (img ou video)
            if (mediaType === 'img') {
                const img = document.createElement('img');
                img.src = url;
                img.onerror = () => {
                    console.error("Erro ao carregar imagem de URL:", url);
                    // Limpar para mostrar o placeholder padrão
                    previewContainer.innerHTML = '';
                    previewContainer.appendChild(inputElement);
                    
                    const previewIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    previewIcon.setAttribute("viewBox", "0 0 24 24");
                    const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    iconPath.setAttribute("d", "M19 7v2.99s-1.99.01-2 0V7h-3s.01-1.99 0-2h3V2h2v3h3v2h-3zm-3 4V8h-3V5H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-8h-3zM5 19l3-4 2 3 3-4 4 5H5z");
                    previewIcon.appendChild(iconPath);
                    previewContainer.appendChild(previewIcon);
                    
                    const previewText = document.createElement('span');
                    previewText.textContent = 'Clique, arraste ou cole uma imagem/vídeo';
                    previewContainer.appendChild(previewText);
                };
                previewContainer.appendChild(img);
            } else if (mediaType === 'video') {
                const video = document.createElement('video');
                video.src = url;
                video.controls = true;
                video.onerror = () => {
                    console.error("Erro ao carregar vídeo de URL:", url);
                    // Limpar para mostrar o placeholder padrão
                    previewContainer.innerHTML = '';
                    previewContainer.appendChild(inputElement);
                    
                    const previewIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    previewIcon.setAttribute("viewBox", "0 0 24 24");
                    const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    iconPath.setAttribute("d", "M19 7v2.99s-1.99.01-2 0V7h-3s.01-1.99 0-2h3V2h2v3h3v2h-3zm-3 4V8h-3V5H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-8h-3zM5 19l3-4 2 3 3-4 4 5H5z");
                    previewIcon.appendChild(iconPath);
                    previewContainer.appendChild(previewIcon);
                    
                    const previewText = document.createElement('span');
                    previewText.textContent = 'Clique, arraste ou cole uma imagem/vídeo';
                    previewContainer.appendChild(previewText);
                };
                previewContainer.appendChild(video);
            }
        }

        // --- Save Functions ---
        function saveAsJson() {
            showStatus("Gerando JSON...");
            const scenesData = getStoryboardData();
            // Remove previewId before saving JSON, as file refs aren't saved
            const dataToSave = scenesData.map(scene => ({
                 ...scene,
                 shots: scene.shots.map(shot => ({ title: shot.title, description: shot.description }))
            }));
            const dataStr = JSON.stringify({ scenes: dataToSave, savedSettings: settings }, null, 2);
            triggerDownload(dataStr, 'storyboard.json', 'application/json');
            showStatus("JSON salvo.");
        }

        // --- Project Info & Logo Handling ---
        function setupProjectInfoListeners() {
            // Listeners para spans editáveis
            movieNameEditableSpan.addEventListener('blur', () => {
                projectInfo.movieName = movieNameEditableSpan.innerText;
            });
            clientNameEditableSpan.addEventListener('blur', () => {
                projectInfo.clientName = clientNameEditableSpan.innerText;
            });
            
            // Listener para a cor do título do filme
            movieTitleColorInput.addEventListener('input', () => {
                const colorValue = movieTitleColorInput.value;
                projectInfo.movieTitleColor = colorValue;
                root.style.setProperty('--movie-title-color', colorValue);
                movieColorHexInput.value = colorValue;
            });
            
            // Listener para o campo hex da cor do filme
            movieColorHexInput.addEventListener('input', () => {
                try {
                    // Verificar se é um código hex válido
                    const isValid = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(movieColorHexInput.value);
                    if (isValid) {
                        const colorValue = movieColorHexInput.value;
                        projectInfo.movieTitleColor = colorValue;
                        root.style.setProperty('--movie-title-color', colorValue);
                        movieTitleColorInput.value = colorValue;
                    }
                } catch (e) {
                    console.error("Erro ao processar código de cor:", e);
                }
            });
            
            // Listener para o tamanho da fonte do filme
            movieFontSizeInput.addEventListener('input', () => {
                const fontSize = movieFontSizeInput.value;
                projectInfo.movieFontSize = fontSize;
                root.style.setProperty('--movie-font-size', `${fontSize}px`);
            });
            
            // Listener para a cor do nome do cliente
            clientNameColorInput.addEventListener('input', () => {
                const colorValue = clientNameColorInput.value;
                projectInfo.clientNameColor = colorValue;
                root.style.setProperty('--client-name-color', colorValue);
                clientColorHexInput.value = colorValue;
            });
            
            // Listener para o campo hex da cor do cliente
            clientColorHexInput.addEventListener('input', () => {
                try {
                    // Verificar se é um código hex válido
                    const isValid = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(clientColorHexInput.value);
                    if (isValid) {
                        const colorValue = clientColorHexInput.value;
                        projectInfo.clientNameColor = colorValue;
                        root.style.setProperty('--client-name-color', colorValue);
                        clientNameColorInput.value = colorValue;
                    }
                } catch (e) {
                    console.error("Erro ao processar código de cor:", e);
                }
            });
            
            // Listener para o tamanho da fonte do cliente
            clientFontSizeInput.addEventListener('input', () => {
                const fontSize = clientFontSizeInput.value;
                projectInfo.clientFontSize = fontSize;
                root.style.setProperty('--client-font-size', `${fontSize}px`);
            });
            
            // Listener para o espaçamento entre os textos
            textSpacingInput.addEventListener('input', function() {
                const spacing = this.value;
                projectInfo.textSpacing = spacing;
                
                // Agora aplicamos o espaçamento diretamente como margin-bottom do container do filme
                root.style.setProperty('--project-text-gap', `${spacing}px`);
                spacingValueDisplay.textContent = `${spacing}px`;
                
                // Aplicar diretamente à margem do container do filme
                const movieContainer = document.querySelector('.movie-name-container');
                if (movieContainer) {
                    movieContainer.style.marginBottom = `${spacing}px`;
                }
            });
            
            // Listeners da logo
            logoContainer.addEventListener('click', () => {
                logoInput.click();
            });
            logoInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        projectInfo.logoDataUrl = e.target.result;
                        displayLogo(projectInfo.logoDataUrl);
                    };
                    reader.readAsDataURL(file);
                }
                event.target.value = null; 
            });
        }

        function displayLogo(logoDataUrl) {
            if (logoDataUrl) {
                logoImage.src = logoDataUrl;
                logoImage.style.display = 'block';
                logoPlaceholder.style.display = 'none';
            } else {
                logoImage.src = '';
                logoImage.style.display = 'none';
                logoPlaceholder.style.display = 'block';
            }
        }

        function updateProjectInfoUI() {
            // Atualizar spans editáveis
            movieNameEditableSpan.innerText = projectInfo.movieName || 'Nome do Filme Editável';
            clientNameEditableSpan.innerText = projectInfo.clientName || 'Cliente Editável';
            
            // Atualizar a cor do título do filme
            if (projectInfo.movieTitleColor) {
                movieTitleColorInput.value = projectInfo.movieTitleColor;
                movieColorHexInput.value = projectInfo.movieTitleColor;
                root.style.setProperty('--movie-title-color', projectInfo.movieTitleColor);
            }
            
            // Atualizar tamanho da fonte do filme
            if (projectInfo.movieFontSize) {
                movieFontSizeInput.value = projectInfo.movieFontSize;
                root.style.setProperty('--movie-font-size', `${projectInfo.movieFontSize}px`);
            }
            
            // Atualizar a cor do nome do cliente
            if (projectInfo.clientNameColor) {
                clientNameColorInput.value = projectInfo.clientNameColor;
                clientColorHexInput.value = projectInfo.clientNameColor;
                root.style.setProperty('--client-name-color', projectInfo.clientNameColor);
            }
            
            // Atualizar tamanho da fonte do cliente
            if (projectInfo.clientFontSize) {
                clientFontSizeInput.value = projectInfo.clientFontSize;
                root.style.setProperty('--client-font-size', `${projectInfo.clientFontSize}px`);
            }
            
            // Atualizar o espaçamento entre os textos - MODIFICADO PARA USAR MARGIN
            if (projectInfo.textSpacing !== undefined) {
                const spacing = projectInfo.textSpacing;
                textSpacingInput.value = spacing;
                spacingValueDisplay.textContent = `${spacing}px`;
                root.style.setProperty('--project-text-gap', `${spacing}px`);
                
                // Aplicar diretamente à margem do container do filme
                const movieContainer = document.querySelector('.movie-name-container');
                if (movieContainer) {
                    movieContainer.style.marginBottom = `${spacing}px`;
                }
            }
            
            displayLogo(projectInfo.logoDataUrl);
        }

        // --- Save/Load com Project Info --- 
        async function saveToLocalStorage() {
            try {
                showStatus("Salvando no navegador...");
                const scenes = getStoryboardData();
                
                // Process shots for Base64 images (as before)
                const scenesWithImages = [];
                for (const scene of scenes) {
                    const sceneWithImages = {
                        title: scene.title,
                        description: scene.description,
                        shots: []
                    };
                    for (const shot of scene.shots) {
                        const shotWithImage = {
                            title: shot.title,
                            description: shot.description,
                            imageData: null,
                            imageType: null
                        };
                        if (shot.previewId) {
                            const previewContainer = document.querySelector(`.shot-preview[data-preview-id="${shot.previewId}"]`);
                            if (previewContainer) {
                                const mediaElement = previewContainer.querySelector('img, video');
                                if (mediaElement) {
                                    try {
                                        if (fileReferences[shot.previewId]) {
                                            const file = fileReferences[shot.previewId];
                                            shotWithImage.imageData = await readFileAsBase64(file);
                                            shotWithImage.imageType = file.type;
                                        } else if (mediaElement.tagName.toLowerCase() === 'img') {
                                            const canvas = document.createElement('canvas');
                                            canvas.width = mediaElement.naturalWidth;
                                            canvas.height = mediaElement.naturalHeight;
                                            const ctx = canvas.getContext('2d');
                                            ctx.drawImage(mediaElement, 0, 0);
                                            shotWithImage.imageData = canvas.toDataURL('image/jpeg', 0.85);
                                            shotWithImage.imageType = 'image/jpeg';
                                        } else if (mediaElement.tagName.toLowerCase() === 'video') {
                                            if (!mediaElement.src.startsWith('blob:')) {
                                                shotWithImage.imageData = mediaElement.src;
                                                shotWithImage.imageType = 'video-url';
                                            }
                                        }
                                    } catch (e) { console.error("Erro ao processar mídia:", e); }
                                }
                            }
                        }
                        sceneWithImages.shots.push(shotWithImage);
                    }
                    scenesWithImages.push(sceneWithImages);
                }
                
                // Combine scenes, settings, and project info
                const dataToSave = {
                    scenes: scenesWithImages,
                    settings: settings,
                    projectInfo: projectInfo // projectInfo já está atualizado pelos listeners 'blur'
                };
                
                localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(dataToSave));
                showStatus("Salvo no navegador com sucesso!");
            } catch (e) {
                console.error("Error saving to localStorage:", e);
                if (e.name === 'QuotaExceededError') {
                    showStatus("Erro: Limite de armazenamento do navegador excedido!", 5000);
                } else {
                    showStatus("Erro ao salvar no navegador: " + e.message, 5000);
                }
            }
        }

        function loadFromLocalStorage() {
            let needsDefaultScene = true;
            try {
                const savedState = localStorage.getItem(LOCALSTORAGE_KEY);
                if (savedState) {
                    try {
                        const state = JSON.parse(savedState);
                        if (state) { // Checar se state existe
                            // Carregar Project Info PRIMEIRO
                            projectInfo = { ...projectInfo, ...(state.projectInfo || {}) }; 
                            updateProjectInfoUI();

                            // Carregar Configurações
                            loadSettingsFromState(state); // Passar state completo
                            
                            // Construir Storyboard se houver cenas
                            if (state.scenes && Array.isArray(state.scenes) && state.scenes.length > 0) {
                                buildStoryboardFromData(state.scenes);
                                needsDefaultScene = false;
                            }
                            
                            showStatus("Storyboard carregado do navegador com sucesso.", 2000);
                        } else {
                            // Estado salvo inválido
                            console.warn("Saved state exists but is invalid or empty");
                            localStorage.removeItem(LOCALSTORAGE_KEY);
                            loadSettingsFromState({}); // Carregar settings padrão
                            updateProjectInfoUI(); // UI com info padrão
                        }
                    } catch (e) {
                        // Erro ao parsear JSON
                        console.error("Error parsing localStorage:", e);
                        localStorage.removeItem(LOCALSTORAGE_KEY);
                        loadSettingsFromState({});
                        updateProjectInfoUI();
                    }
                } else {
                    // Nenhum estado salvo
                    loadSettingsFromState({});
                    updateProjectInfoUI();
                }
            } catch (e) {
                // Erro crítico
                console.error("Critical error in loadFromLocalStorage:", e);
                loadSettingsFromState({});
                updateProjectInfoUI();
            }
            
            // Adicionar cena padrão se necessário
            if (needsDefaultScene && scenesContainer.children.length === 0) {
                console.log("Adding default scene as none were loaded");
                addScene();
            }
        }

        // --- Load Functions ---
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type === 'application/json') {
                loadStoryboardFromJsonFile(file);
            } else {
                alert("Tipo de arquivo inválido. Selecione um arquivo .json.");
            }
            event.target.value = null; // Allow re-selecting same file
        }

        function loadStoryboardFromJsonFile(file) {
             showStatus("Carregando JSON...");
             const reader = new FileReader();
             reader.onload = function(e) {
                 try {
                     const data = JSON.parse(e.target.result);
                     if (data && data.scenes) {
                         buildStoryboardFromData(data.scenes);
                         // Load settings from JSON if they exist
                         if (data.savedSettings) {
                             settings = { ...defaultSettings, ...data.savedSettings };
                             applySettings();
                             updateSettingsUI();
                         }
                         showStatus("Storyboard JSON carregado. Mídias precisam ser adicionadas novamente.", 4000);
                     } else { showStatus('Arquivo JSON inválido.', 5000); }
                 } catch (error) { showStatus('Erro ao carregar JSON: ' + error.message, 5000); }
             };
             reader.onerror = function() { showStatus('Erro ao ler o arquivo JSON.', 5000); };
             reader.readAsText(file);
        }

        // --- Download Trigger Utility ---
        function triggerDownload(data, filename, type) {
            const blob = new Blob([data], { type: type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // --- Media Handling (Keep existing logic, ensure fileReferences is updated) ---
        function triggerFileInput(previewContainer) { if (event.target === previewContainer || event.target.tagName === 'SPAN' || event.target.tagName === 'svg' || event.target.tagName === 'path') { previewContainer.querySelector('.hidden-input').click(); } }
        function handleFileSelect(event, inputElement) { const file = event.target.files[0]; if (!file) return; displayMedia(file, inputElement.closest('.shot-preview')); event.target.value = null; }
        function handlePaste(event, previewContainer) { const items = (event.clipboardData || window.clipboardData).items; for (const item of items) { if (item.kind === 'file' && item.type.startsWith('image/')) { const file = item.getAsFile(); displayMedia(file, previewContainer); event.preventDefault(); break; } } }
        function handleDragOver(event, previewContainer) { 
            event.preventDefault(); 
            // <<< NOVO: Ignorar se estivermos arrastando um shot >>>
            if (draggedShot) { 
                 console.log("DragOver ignorado no preview (arrastando shot).");
                 // Manter o dropEffect padrão ou como 'none' para não mostrar o ícone de drop inválido
                 event.dataTransfer.dropEffect = 'none'; 
                 return; 
            }
            // Permitir drop de arquivos
            event.dataTransfer.dropEffect = 'copy'; 
            previewContainer.classList.add('drag-over'); 
        }
        function handleDragLeave(event, previewContainer) { 
            event.preventDefault(); 
            previewContainer.classList.remove('drag-over'); 
        }
        function handleDrop(event, previewContainer) { 
            event.preventDefault(); 
            previewContainer.classList.remove('drag-over'); 
            // <<< NOVO: Ignorar se estivermos arrastando um shot >>>
            if (draggedShot) { 
                console.log("Drop ignorado no preview (arrastando shot).");
                return; 
            }
            const files = event.dataTransfer.files; 
            if (files.length > 0) { const file = files[0]; if (file.type.startsWith('image/') || file.type.startsWith('video/')) { displayMedia(file, previewContainer); } else { alert('Tipo de arquivo não suportado.'); } } }
        function displayMedia(file, previewContainer) {
            const previewId = previewContainer.dataset.previewId;
            if (!previewId) { console.error("Preview container missing ID!"); return; }
            fileReferences[previewId] = file;
            
            console.log("Exibindo mídia:", file.type, file.name);

            let inputElement = previewContainer.querySelector('.hidden-input');
            previewContainer.innerHTML = ''; // Clear completely
            if (!inputElement) { // Recreate if cleared
                inputElement = document.createElement('input');
                inputElement.type = 'file';
                inputElement.className = 'hidden-input';
                inputElement.accept = 'image/*,video/*';
                inputElement.onchange = (event) => handleFileSelect(event, inputElement);
            }
            previewContainer.appendChild(inputElement);

            const shotCard = previewContainer.closest('.shot');

            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.onerror = () => console.error("Erro ao carregar imagem:", img.src?.substring(0,100));

                // Verificar se é um GIF ou WebP animado - todos WebP são tratados como potencialmente animados
                const isAnimated = file.type.toLowerCase() === 'image/gif' || file.type.toLowerCase() === 'image/webp';
                console.log("É imagem animada?", isAnimated, file.type);
                
                if (isAnimated) {
                    console.log(`Processando ${file.type} para hover...`);
                    readFileAsBase64(file).then(animatedDataUrl => {
                        img.dataset.animatedSrc = animatedDataUrl;
                        img.dataset.fileType = file.type; // Guardar o tipo de arquivo
                        console.log("Data URL animada armazenada.");
                        createStaticImageFromAnimated(file).then(staticDataUrl => {
                            console.log(`Versão estática criada para ${file.type}.`);
                            img.dataset.staticSrc = staticDataUrl;
                            img.src = staticDataUrl;
                            previewContainer.appendChild(img);
                            
                            // Adicionar botão de edição para GIF/WebP
                            const editButton = document.createElement('button');
                            editButton.className = 'edit-video-button';
                            editButton.innerHTML = '✂️';
                            editButton.title = 'Editar pontos de entrada/saída';
                            editButton.onclick = (e) => {
                                e.stopPropagation(); // Prevent triggering file input
                                console.log("Clicou em editar imagem animada", img);
                                openTrimModal(img); // Passar a imagem para o modal
                            };
                            previewContainer.appendChild(editButton);
                            
                            applyHoverEvents(shotCard, previewContainer);
                        }).catch(err => {
                            console.warn(`Falha ao criar versão estática para ${file.type}: ${err.message}. Usando animada.`);
                            img.src = animatedDataUrl;
                            previewContainer.appendChild(img);
                            
                            // Adicionar botão de edição mesmo com imagem animada
                            const editButton = document.createElement('button');
                            editButton.className = 'edit-video-button';
                            editButton.innerHTML = '✂️';
                            editButton.title = 'Editar pontos de entrada/saída';
                            editButton.onclick = (e) => {
                                e.stopPropagation();
                                console.log("Clicou em editar imagem animada (fallback)", img);
                                openTrimModal(img);
                            };
                            previewContainer.appendChild(editButton);
                        });
                    }).catch(err => {
                        console.error(`Erro ao ler ${file.type} como Data URL: ${err.message}`);
                        const fallbackUrl = URL.createObjectURL(file);
                        img.src = fallbackUrl;
                        img.onload = () => URL.revokeObjectURL(fallbackUrl);
                        previewContainer.appendChild(img);
                    });
                } else {
                    const objectURL = URL.createObjectURL(file);
                    img.src = objectURL;
                    img.onload = () => URL.revokeObjectURL(objectURL);
                    previewContainer.appendChild(img);
                    applyHoverEvents(shotCard, previewContainer); // Apply hover for static images too
                }
            } else if (file.type.startsWith('video/')) {
                const video = document.createElement('video');
                const objectURL = URL.createObjectURL(file);
                video.src = objectURL;
                video.onloadedmetadata = () => {
                    console.log("Vídeo carregado com duração:", video.duration);
                    // Set default trim points to full duration
                    video.dataset.startTime = 0;
                    video.dataset.endTime = video.duration;
                    applyHoverEvents(shotCard, previewContainer); // Apply hover events *after* metadata loaded
                };
                video.onerror = () => console.error("Erro ao carregar vídeo:", objectURL);
                video.controls = false;
                video.autoplay = false;
                video.loop = true;
                video.muted = true;
                video.preload = "metadata";
                previewContainer.appendChild(video);

                // Botão de edição que abre o MODAL
                const editButton = document.createElement('button');
                editButton.className = 'edit-video-button';
                editButton.innerHTML = '✂️';
                editButton.title = 'Editar pontos de entrada/saída';
                editButton.onclick = (e) => {
                    e.stopPropagation(); // Prevent triggering file input
                    console.log("Clicou em editar vídeo", video);
                    openTrimModal(video); // Pass the original video element
                };
                previewContainer.appendChild(editButton);
            }

            // Ensure event listeners are (re)attached to the preview container
            previewContainer.onclick = (event) => triggerFileInput(previewContainer, event);
            previewContainer.onpaste = (event) => handlePaste(event, previewContainer);
            previewContainer.ondragover = (event) => handleDragOver(event, previewContainer);
            previewContainer.ondragleave = (event) => handleDragLeave(event, previewContainer);
            previewContainer.ondrop = (event) => handleDrop(event, previewContainer);
        }

        // --- Utility Functions (Keep existing logic) ---
        function autoResize(textarea) {
            // Salvar a altura atual para comparação
            const previousHeight = textarea.style.height;
            
            // Reset da altura para calcular o novo tamanho
            textarea.style.height = 'auto';
            
            // Definir a nova altura com base no scrollHeight
            const newHeight = Math.max(textarea.scrollHeight, textarea.clientHeight);
            textarea.style.height = newHeight + 'px';
        }
        function autoSizeInput(input, charWidthEstimate = 10) { const minWidth = parseInt(getComputedStyle(input).minWidth) || 50; const calculatedWidth = (input.value.length + 2) * charWidthEstimate; input.style.width = Math.max(minWidth, calculatedWidth) + 'px'; }
        function sanitizeFilename(name) { return name.replace(/[^a-z0-9_\-\.]/gi, '_').replace(/_{2,}/g, '_'); }
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Check libraries needed for export
                if (typeof JSZip === 'undefined') {
                    console.error("JSZip library not found! ZIP export will be disabled.");
                    if (exportZipBtn) {
                        exportZipBtn.disabled = true;
                        exportZipBtn.title = "Erro: Biblioteca JSZip não encontrada.";
                    }
                }
                
                if ((typeof jsPDF === 'undefined' && typeof window.jspdf === 'undefined') || typeof html2canvas === 'undefined') {
                    console.error("jsPDF or html2canvas library not found! PDF export will be disabled.");
                    if (exportPdfBtn) {
                        exportPdfBtn.disabled = true;
                        exportPdfBtn.title = "Erro: Bibliotecas PDF não encontradas.";
                    }
                }

                // Ensure we always have the settings panel
                if (!settingsPanel) {
                    console.error("Settings panel not found!");
                }

                // Setup listeners for project info inputs
                setupProjectInfoListeners(); 
                setupSettingsListeners(); // <<< GARANTIR que este também é chamado
                
                // NEW: Setup Modal Listeners
                setupModalListeners();
                
                // NEW: Setup Drag and Drop listeners for shots
                console.log("[INIT] Configurando listeners para arrastar e soltar shots...");
                setupShotDragDropListeners(); // <<< Adicionar esta chamada
                
                // Carregar do localStorage
                loadFromLocalStorage();
                
            } catch (e) {
                console.error("Error during initialization:", e);
                // Force add a scene if everything else fails
                if (scenesContainer && scenesContainer.children.length === 0) {
                    addScene();
                }
            }
        });

        // Script para controlar o dropdown
        function toggleDropdown() {
            document.getElementById('saveDropdown').classList.toggle('show');
            // Fechar o dropdown quando clicar fora dele
            document.addEventListener('click', closeDropdownOutside);
        }

        function hideDropdown() {
            document.getElementById('saveDropdown').classList.remove('show');
            document.removeEventListener('click', closeDropdownOutside);
        }

        function closeDropdownOutside(event) {
            // Não fechar se o clique foi no botão que abre o dropdown
            if (event.target.matches('.header-btn') && event.target.closest('.dropdown')) {
                return;
            }
            
            // Não fechar se o clique foi dentro do dropdown
            if (event.target.closest('#saveDropdown')) {
                return;
            }
            
            // Fechar o dropdown
            hideDropdown();
            
            // Remover este listener após o primeiro clique
            document.removeEventListener('click', closeDropdownOutside);
        }

        // Depois, adicionar a função para salvar como HTML
        async function saveAsHTML() {
            try {
                showStatus("Gerando HTML completo...");
                const staticDoc = document.implementation.createHTMLDocument("Storyboard Completo");
                const headClone = document.head.cloneNode(true);
                staticDoc.head.replaceWith(headClone);
                const bodyContainer = staticDoc.createElement('div');
                bodyContainer.className = 'container';
                staticDoc.body.appendChild(bodyContainer);
                
                // Clonar e adicionar Detalhes do Projeto (agora .project-info-loose)
                const projectInfoClone = projectInfoSection.cloneNode(true); // <<< ATUALIZADO classe
                projectInfoClone.querySelector('.logo-container').onclick = null;
                projectInfoClone.querySelector('.logo-container').style.cursor = 'default';
                // Remover input file da logo no clone
                const logoInputClone = projectInfoClone.querySelector('#logo-input');
                if(logoInputClone) logoInputClone.remove();
                projectInfoClone.querySelectorAll('span[contenteditable="true"]').forEach(span => {
                    span.contentEditable = false;
                    span.style.borderBottom = 'none';
                    span.style.cursor = 'default';
                });
                bodyContainer.appendChild(projectInfoClone);
                
                // Clonar e adicionar Cenas (como antes)
                const scenesContainerClone = scenesContainer.cloneNode(true);
                // ... (remover interatividade das cenas/shots) ...
                bodyContainer.appendChild(scenesContainerClone);

                // ... (lógica de incorporar Base64 como antes) ...
                let newHtmlContent = staticDoc.documentElement.outerHTML;
                // ... (loop para substituir blobs por base64) ...
                triggerDownload(newHtmlContent, 'storyboard_completo.html', 'text/html');
                showStatus("HTML completo salvo com sucesso!");
            } catch (e) {
                // ... (tratamento de erro) ...
            }
        }

        async function exportZipStatic() {
            console.log("[ZIP Export] Iniciando...");
            showStatus("Iniciando exportação ZIP...");
            
            // Verificar se JSZip está disponível
            if (typeof JSZip === 'undefined') {
                console.error("JSZip library not found! ZIP export will be disabled.");
                showStatus("Erro: Biblioteca JSZip não encontrada. Exportação ZIP desabilitada.", 5000);
                return;
            }

            // Criar um novo objeto ZIP
            const zip = new JSZip();
            const parser = new DOMParser();
            const staticHtmlDoc = parser.parseFromString('<!DOCTYPE html><html><head></head><body></body></html>', 'text/html');

            try {
                // 1. Copiar head (including library scripts)
                console.log("[ZIP Export] Copiando HEAD com estilos e scripts de libs...");
                const currentHead = document.head.cloneNode(true);
                // Remove the main script block to avoid duplicating definitions if we inject them later
                currentHead.querySelectorAll('script').forEach(s => {
                     // Heuristic: Remove large inline scripts assuming it's the main logic block
                     // Keep library scripts loaded via src
                     if (!s.hasAttribute('src') && s.textContent.length > 1000) {
                         console.log("[ZIP Export] Removendo script inline grande do head clonado.");
                         s.remove();
                     }
                });
                staticHtmlDoc.head.replaceWith(currentHead);

                // 2. Montar body
                console.log("[ZIP Export] Montando BODY com container...");
                const bodyContainer = staticHtmlDoc.createElement('div');
                bodyContainer.className = 'container';
                staticHtmlDoc.body.appendChild(bodyContainer);
                staticHtmlDoc.body.style.fontFamily = getComputedStyle(document.body).fontFamily;

                // 3. Clonar e limpar Detalhes do Projeto
                console.log("[ZIP Export] Clonando e limpando Detalhes do Projeto...");
                const projectInfoOriginal = document.querySelector('.project-info-loose');
                if (projectInfoOriginal) {
                    const projectInfoClone = projectInfoOriginal.cloneNode(true);
                    projectInfoClone.querySelectorAll('.style-controls, .spacing-container, #logo-input').forEach(el => el.remove());
                    projectInfoClone.querySelectorAll('[contenteditable="true"]').forEach(span => {
                        span.removeAttribute('contenteditable');
                        span.style.borderBottom = 'none';
                        span.style.cursor = 'default';
                        span.style.backgroundColor = 'transparent';
                    });
                    const logoContainerClone = projectInfoClone.querySelector('.logo-container');
                    if (logoContainerClone) {
                        const logoImageClone = logoContainerClone.querySelector('#logo-image');
                        const logoPlaceholderClone = logoContainerClone.querySelector('#logo-placeholder');
                        logoContainerClone.onclick = null;
                        logoContainerClone.style.cursor = 'default';
                        logoContainerClone.title = '';
                        if (logoImageClone && logoImageClone.getAttribute('src') && logoImageClone.style.display !== 'none') {
                            if(logoPlaceholderClone) logoPlaceholderClone.remove();
                            logoContainerClone.style.border = 'none';
                        } else {
                            logoContainerClone.remove();
                        }
                    }
                    bodyContainer.appendChild(projectInfoClone);
                }

                // 4. Clonar e limpar Cenas
                console.log("[ZIP Export] Clonando e limpando Cenas...");
                const scenesContainerOriginal = document.getElementById('scenesContainer');
                if (scenesContainerOriginal) {
                    const scenesContainerClone = scenesContainerOriginal.cloneNode(true);
                    scenesContainerClone.querySelectorAll('.scene-title-input, .shot-title-input').forEach(input => {
                        const span = staticHtmlDoc.createElement('span');
                        span.textContent = input.value;
                        span.className = input.className.replace('-input', '-static');
                        span.style.border = 'none'; span.style.padding = getComputedStyle(input).padding;
                        input.replaceWith(span);
                    });
                    scenesContainerClone.querySelectorAll('textarea').forEach(textarea => {
                        const div = staticHtmlDoc.createElement('div');
                        div.textContent = textarea.value;
                        div.className = textarea.className.replace('textarea', 'static-desc');
                        div.style.whiteSpace = 'pre-wrap'; div.style.padding = getComputedStyle(textarea).padding;
                        div.style.border = 'none'; div.style.minHeight = 'auto'; div.style.height = 'auto';
                        div.style.backgroundColor = 'transparent';
                        textarea.replaceWith(div);
                    });
                    scenesContainerClone.querySelectorAll('.delete-scene-btn, .delete-shot-btn, .add-shot-btn-header, .edit-video-button, .hidden-input').forEach(el => el.remove());
                    bodyContainer.appendChild(scenesContainerClone);
                }

                // 5. Processar mídias (Copy attributes carefully)
                console.log("[ZIP Export] Processando mídias...");
                const mediaPreviewsClone = Array.from(bodyContainer.querySelectorAll('.shot-preview'));
                const mediaFolder = 'media';
                
                // IMPORTANTE: Primeiro, criar as pastas no ZIP para evitar o erro "NotFoundError"
                // Criar a pasta raiz de mídia
                zip.folder(mediaFolder);
                
                // Coletar todos os nomes de pastas de cenas que serão necessários
                const sceneFolderNames = new Set();
                mediaPreviewsClone.forEach(previewContainerClone => {
                    const sceneEl = previewContainerClone.closest('.scene');
                    if (sceneEl) {
                        const sceneTitle = sceneEl.querySelector('.scene-title-static')?.textContent || 'scene';
                        const sceneFolderName = `scene_${sanitizeFilename(sceneTitle.toLowerCase().substring(0,15))}`;
                        sceneFolderNames.add(sceneFolderName);
                    }
                });
                
                // Criar todas as pastas de cenas dentro da pasta de mídia
                sceneFolderNames.forEach(sceneFolderName => {
                    zip.folder(`${mediaFolder}/${sceneFolderName}`);
                });
                
                const filePromises = [];

                for (const previewContainerClone of mediaPreviewsClone) {
                    const originalPreviewId = previewContainerClone.dataset.previewId;
                    const mediaElementClone = previewContainerClone.querySelector('img, video');
                    previewContainerClone.querySelectorAll('svg, span:not([class*="-static"])').forEach(el => el.remove());

                    const originalPreviewContainer = document.querySelector(`.shot-preview[data-preview-id="${originalPreviewId}"]`);
                    if (originalPreviewContainer && originalPreviewId && fileReferences[originalPreviewId] && mediaElementClone) {
                        const file = fileReferences[originalPreviewId];
                        const originalMediaElement = originalPreviewContainer.querySelector('img, video');
                        if (!originalMediaElement) { continue; }

                        const isVideo = mediaElementClone.tagName.toLowerCase() === 'video';
                        const isAnimated = !isVideo && (file.type.includes('gif') || file.type.includes('webp'));

                        // Determine file paths
                        const sceneEl = previewContainerClone.closest('.scene');
                        const shotEl = previewContainerClone.closest('.shot');
                        const sceneTitle = sceneEl?.querySelector('.scene-title-static')?.textContent || 'scene';
                        const shotTitle = shotEl?.querySelector('.shot-title-static')?.textContent || 'shot';
                        const sceneFolderName = `scene_${sanitizeFilename(sceneTitle.toLowerCase().substring(0,15))}`;
                        const shotFileNameBase = `shot_${sanitizeFilename(shotTitle.toLowerCase().substring(0,15))}`;
                        const fileExtension = file.name.split('.').pop() || (isVideo ? 'mp4' : (isAnimated ? file.type.split('/')[1] : 'jpg'));
                        const uniqueSuffix = Date.now().toString(36) + Math.random().toString(36).substring(2,5);
                        const finalFileName = `${shotFileNameBase}_${uniqueSuffix}.${fileExtension}`;
                        const zipPath = `${mediaFolder}/${sceneFolderName}/${finalFileName}`;
                        const relativeHtmlPath = zipPath;

                        console.log(`[ZIP Export] Adicionando: ${zipPath}`);
                        
                        try {
                            filePromises.push(zip.file(zipPath, file, { binary: true }));

                            if (isVideo) {
                                mediaElementClone.src = relativeHtmlPath;
                                mediaElementClone.removeAttribute('controls');
                                mediaElementClone.loop = true; 
                                mediaElementClone.muted = true; 
                                mediaElementClone.preload = 'metadata';
                                mediaElementClone.setAttribute('playsinline', '');

                                // Copy data attributes directly
                                const startTime = originalMediaElement.dataset.startTime;
                                const endTime = originalMediaElement.dataset.endTime;
                                mediaElementClone.dataset.startTime = startTime !== undefined ? startTime : "0";
                                if (endTime !== undefined) mediaElementClone.dataset.endTime = endTime;
                                else delete mediaElementClone.dataset.endTime;
                            } else if (isAnimated) {
                                try {
                                    const staticDataUrl = await createStaticImageFromAnimated(file);
                                    const staticBlob = await (await fetch(staticDataUrl)).blob();
                                    const staticFileName = `${shotFileNameBase}_${uniqueSuffix}_static.png`;
                                    const staticZipPath = `${mediaFolder}/${sceneFolderName}/${staticFileName}`;
                                    const staticRelativeHtmlPath = staticZipPath;
                                    filePromises.push(zip.file(staticZipPath, staticBlob, { binary: true }));

                                    mediaElementClone.src = staticRelativeHtmlPath;
                                    mediaElementClone.dataset.staticSrc = staticRelativeHtmlPath;
                                    mediaElementClone.dataset.animatedSrc = relativeHtmlPath;
                                    mediaElementClone.setAttribute('data-static-src', staticRelativeHtmlPath);
                                    mediaElementClone.setAttribute('data-animated-src', relativeHtmlPath);
                                } catch (error) {
                                    console.error(`[ZIP Export] Falha thumbnail estático para ${finalFileName}:`, error);
                                    mediaElementClone.src = relativeHtmlPath;
                                    delete mediaElementClone.dataset.staticSrc;
                                    delete mediaElementClone.dataset.animatedSrc;
                                    mediaElementClone.removeAttribute('data-static-src');
                                    mediaElementClone.removeAttribute('data-animated-src');
                                }
                            } else {
                                mediaElementClone.src = relativeHtmlPath;
                                delete mediaElementClone.dataset.staticSrc;
                                delete mediaElementClone.dataset.animatedSrc;
                                mediaElementClone.removeAttribute('data-static-src');
                                mediaElementClone.removeAttribute('data-animated-src');
                            }
                        } catch (error) {
                            console.error(`[ZIP Export] Erro ao processar arquivo ${zipPath}:`, error);
                            // Continuar mesmo se houver erro em um arquivo
                        }
                    } else {
                        console.warn(`[ZIP Export] Mídia não encontrada/referenciada para ${originalPreviewId}.`);
                        previewContainerClone.innerHTML = '<span>Mídia não incluída</span>';
                    }
                    if(previewContainerClone.dataset.previewId) delete previewContainerClone.dataset.previewId;
                }

                console.log(`[ZIP Export] ${filePromises.length} arquivos de mídia sendo adicionados.`);
                await Promise.all(filePromises);
                console.log("[ZIP Export] Mídias adicionadas ao ZIP.");

                // Script para a versão estática
                console.log("[ZIP Export] Injetando script com definições de hover e inicialização...");
                const finalScript = staticHtmlDoc.createElement('script');
                finalScript.textContent = `
// --- Função ajustada para aplicar reprodução automática no hover ---
function applyStaticHoverEvents(shotCard, previewContainer) {
    if (!shotCard || !previewContainer) {
        console.warn("Elemento shotCard ou previewContainer não encontrado.");
        return;
    }

    const video = previewContainer.querySelector('video');
    const img = previewContainer.querySelector('img[data-animated-src][data-static-src]');

    if (video) {
        // Preparar vídeo para autoplay
        video.muted = true;
        video.playsInline = true;
        video.preload = "auto";

        // Forçar carregamento
        video.load();

        shotCard.addEventListener('mouseenter', () => {
            if (video.readyState >= 2) { // Tem dados suficientes
                video.play().catch(err => console.error("Erro ao tocar vídeo:", err));
            } else {
                video.addEventListener('canplay', () => video.play().catch(err => console.error("Erro ao tocar vídeo após canplay:", err)), { once: true });
            }
            console.log("Mouse entrou, vídeo iniciando reprodução.");
        });

        shotCard.addEventListener('mouseleave', () => {
            video.pause();
            video.currentTime = 0;
            console.log("Mouse saiu, vídeo pausado e resetado.");
        });
    } else if (img) {
        const animatedSrc = img.getAttribute('data-animated-src');
        const staticSrc = img.getAttribute('data-static-src');

        shotCard.addEventListener('mouseenter', () => {
            if (animatedSrc) {
                img.src = animatedSrc;
                console.log("Mouse entrou, imagem animada ativada.");
            }
        });

        shotCard.addEventListener('mouseleave', () => {
            if (staticSrc) {
                img.src = staticSrc;
                console.log("Mouse saiu, imagem estática restaurada.");
            }
        });
    } else {
        console.warn("Nenhum vídeo ou imagem animada encontrada dentro de previewContainer.");
    }
}

// Aplicar eventos de hover após carregamento do DOM
document.addEventListener('DOMContentLoaded', () => {
    const shotCards = document.querySelectorAll('.shot');

    console.log(\`Encontrados \${shotCards.length} cards para aplicar hover.\`);

    shotCards.forEach((shotCard, index) => {
        const previewContainer = shotCard.querySelector('.shot-preview');
        if (previewContainer) {
            applyStaticHoverEvents(shotCard, previewContainer);
            console.log(\`Eventos hover aplicados ao card \${index + 1}.\`);
        } else {
            console.warn(\`Nenhum previewContainer encontrado no card \${index + 1}.\`);
        }
    });
});
`;
                staticHtmlDoc.body.appendChild(finalScript);
                console.log("[ZIP Export] Final script injected into body.");

                // 7. Adicionar HTML final ao ZIP
                console.log("[ZIP Export] Gerando string HTML final...");
                const baseTag = staticHtmlDoc.head.querySelector('base'); if (baseTag) baseTag.remove();
                const serializer = new XMLSerializer();
                const finalHtmlString = '<!DOCTYPE html>\n' + serializer.serializeToString(staticHtmlDoc);
                zip.file('storyboard.html', finalHtmlString);
                console.log("[ZIP Export] storyboard.html adicionado.");

                // 8. Gerar e baixar o ZIP
                showStatus("Gerando arquivo ZIP...");
                console.log("[ZIP Export] Gerando blob do ZIP...");
                try {
                    const content = await zip.generateAsync({ 
                        type: "blob", 
                        mimeType: "application/zip",
                        compression: "DEFLATE",
                        compressionOptions: {
                            level: 6 // Nível médio de compressão (1-9)
                        }
                    });
                    console.log("[ZIP Export - Success] Blob gerado! Tamanho:", content.size);
                    triggerDownload(content, 'storyboard_interactive_export.zip', 'application/zip');
                    showStatus("Exportação ZIP interativa concluída!", 3000);
                    console.log("[ZIP Export - Success] Download iniciado.");
                } catch (zipError) {
                    console.error("[ZIP Export - Error] Erro ao gerar o arquivo ZIP:", zipError);
                    showStatus("Erro ao gerar o arquivo ZIP: " + zipError.message, 5000);
                }

            } catch (error) {
                console.error("[ZIP Export - Outer Error] Erro inesperado:", error);
                showStatus("Erro inesperado durante a exportação ZIP: " + error.message, 5000);
            }
        }

        // --- Ensure Auxiliary Functions Exist in main script ---
        // sanitizeFilename, createStaticImageFromAnimated, applyHoverEvents, formatTime
        // MUST be defined correctly in the original page's global scope.

        // Keep your working definitions for these:
        function sanitizeFilename(name) { /* ... as before ... */
            if (!name) return 'untitled';
            let sanitized = name.replace(/[^a-z0-9_\-\.]/gi, '_');
            sanitized = sanitized.replace(/_{2,}/g, '_');
            sanitized = sanitized.replace(/^[_.-]+|[_.-]+$/g, '');
            if (!sanitized) return 'untitled';
            return sanitized;
        }
        async function createStaticImageFromAnimated(file) { /* ... as before ... */
             console.log("[Helper] Criando imagem estática para:", file.name, "Tipo:", file.type);
             return new Promise(async (resolve, reject) => {
                 try {
                     const reader = new FileReader();
                     reader.onload = function(e) {
                         const img = new Image();
                         img.onload = () => {
                             console.log("[Helper] Imagem carregada na memória para canvas:", file.name, "Dimensões:", img.naturalWidth, "x", img.naturalHeight);
                             const canvas = document.createElement('canvas');
                             canvas.width = img.naturalWidth || img.width;
                             canvas.height = img.naturalHeight || img.height;
                             if (canvas.width === 0 || canvas.height === 0) {
                                  return reject(new Error("Dimensões da imagem inválidas para canvas (0)"));
                             }
                             try {
                                 const ctx = canvas.getContext('2d');
                                 ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                 const staticUrl = canvas.toDataURL('image/png');
                                 resolve(staticUrl);
                             } catch (canvasError) {
                                 reject(new Error(`Erro no canvas: ${canvasError.message}`));
                             }
                         };
                         img.onerror = (err) => {
                             reject(new Error("Falha ao carregar dados da imagem via Data URL"));
                             reject(new Error("Falha ao carregar dados da imagem via Data URL"));
                         };
                         img.src = e.target.result; // Usar resultado do FileReader (Data URL)
                     };
                     reader.onerror = (err) => {
                         reject(new Error("Falha ao ler o arquivo via FileReader"));
                         reject(new Error("Falha ao ler o arquivo via FileReader"));
                     }
                     reader.readAsDataURL(file); // Ler como Data URL
                 } catch (error) { reject(error); }
             });
         }

        // Adicionar novas funções para os recursos adicionais
        // Função para verificar se um WebP é animado
        function checkIfWebPIsAnimated(file) {
            // Esta é uma verificação simplificada
            // Uma verificação mais robusta envolveria ler o cabeçalho do arquivo
            return file.size > 100000; // Assumir que WebP grandes são animados
        }
        
        // Função para criar imagem estática de um GIF/WebP animado
        async function createStaticImageFromAnimated(file) {
            console.log("Tentando criar imagem estática para:", file.name, "Tipo:", file.type);
            
            // Verificar se é um WebP ou GIF
            const isWebP = file.type.toLowerCase() === 'image/webp';
            const isGif = file.type.toLowerCase() === 'image/gif';
            
            console.log("Tipo de imagem animada detectada:", 
                      isWebP ? "WebP" : (isGif ? "GIF" : "Desconhecido"), 
                      "MIME:", file.type);
            
            return new Promise((resolve, reject) => {
                try {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = () => {
                            console.log("Imagem carregada na memória para canvas:", file.name, "Dimensões:", img.naturalWidth, "x", img.naturalHeight);
                            const canvas = document.createElement('canvas');
                            // Usar naturalWidth/Height se disponível, senão width/height
                            canvas.width = img.naturalWidth || img.width;
                            canvas.height = img.naturalHeight || img.height;
                            if (canvas.width === 0 || canvas.height === 0) {
                                return reject(new Error("Dimensões da imagem inválidas para canvas"));
                            }
                            try {
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                const staticUrl = canvas.toDataURL('image/png'); // Gera PNG estático
                                resolve(staticUrl);
                            } catch (canvasError) {
                                console.error("Erro no canvas ao desenhar imagem:", canvasError);
                                reject(new Error(`Erro no canvas: ${canvasError.message}`));
                            }
                        };
                        img.onerror = (err) => {
                            console.error("Erro ao carregar dados da imagem para Image():", err);
                            reject(new Error("Falha ao carregar dados da imagem"));
                        };
                        img.src = e.target.result; // Usar resultado do FileReader
                    };
                    reader.onerror = (err) => {
                        console.error("Erro no FileReader:", err);
                        reject(new Error("Falha ao ler o arquivo"));
                    }
                    reader.readAsDataURL(file);
                } catch (error) {
                    console.error("Erro geral em createStaticImageFromAnimated:", error);
                    reject(error);
                }
            });
        }
        
        // Controles de edição de vídeo
        function toggleVideoTrimMode(container, video) {
            container.classList.toggle('editing');
            
            if (container.classList.contains('editing')) {
                // Atualizar o UI com valores salvos se existirem
                const startSlider = container.querySelector('.start-time');
                const endSlider = container.querySelector('.end-time');
                const startValue = container.querySelector('.start-value');
                const endValue = container.querySelector('.end-value');
                
                if (video.dataset.startTime !== undefined) {
                    startSlider.value = video.dataset.startTime;
                    startValue.textContent = parseFloat(video.dataset.startTime).toFixed(1) + 's';
                }
                
                if (video.dataset.endTime !== undefined) {
                    endSlider.value = video.dataset.endTime;
                    endValue.textContent = parseFloat(video.dataset.endTime).toFixed(1) + 's';
                }
            }
        }
        
        function previewTrim(video, startTime, endTime) {
            video.currentTime = startTime;
            
            const preview = () => {
                if (video.currentTime >= endTime) {
                    video.pause();
                    return;
                }
                video.play();
                requestAnimationFrame(preview);
            };
            
            preview();
        }

        function saveTrim(video, startTime, endTime) {
            video.dataset.startTime = startTime;
            video.dataset.endTime = endTime;
            video.currentTime = startTime;
        }

        // Função específica para aplicar os eventos de hover a qualquer momento
        function applyHoverEvents(shotCard, previewContainer) {
            if (!shotCard || !previewContainer) {
                 console.warn("[ApplyHover] Missing shotCard or previewContainer");
                 return;
            }

            let hoverTimeout = null; // Timeout reference for video play delay

            shotCard.addEventListener('mouseenter', () => {
                // Clear any pending timeout from previous rapid enter/leave actions
                if (hoverTimeout) clearTimeout(hoverTimeout);

                const mediaElement = previewContainer.querySelector('video, img[data-animated-src]'); // Simplified selector slightly
                if (!mediaElement) {
                     //console.log("[ApplyHover Enter] No media element found in:", previewContainer);
                     return;
                }

                const isVideo = mediaElement.tagName.toLowerCase() === 'video';

                if (isVideo) {
                    // Delay video play slightly to avoid issues with rapid hover-over
                    hoverTimeout = setTimeout(() => {
                        console.log(`[ApplyHover Enter Video] Attempting play. ReadyState: ${mediaElement.readyState}`);
                        mediaElement.muted = true; // Ensure muted
                        const startTime = parseFloat(mediaElement.dataset.startTime || 0);

                        // Always try setting currentTime before playing
                        try {
                            // Check if seeking is possible (readyState > 0)
                            if (mediaElement.readyState > 0) {
                                 mediaElement.currentTime = startTime;
                            } else {
                                 // If not ready, listen for metadata to set time
                                 mediaElement.addEventListener('loadedmetadata', () => {
                                      mediaElement.currentTime = startTime;
                                 }, { once: true });
                            }
                        } catch (timeError) {
                            console.error("[ApplyHover Enter Video] Error setting currentTime:", timeError);
                        }

                        // Attempt to play
                        const playPromise = mediaElement.play();
                        if (playPromise !== undefined) {
                            playPromise.then(() => {
                                console.log(`[ApplyHover Enter Video] Play initiated for src: ${mediaElement.currentSrc.substring(0,50)}...`);
                            }).catch(error => {
                                // Common errors: NotAllowedError (autoplay policy), NotSupportedError
                                console.warn(`[ApplyHover Enter Video] Play failed for src: ${mediaElement.currentSrc.substring(0,50)}... Error:`, error.name, error.message);
                                // We don't need the interval check if play failed
                                if (mediaElement._hoverInterval) {
                                     clearInterval(mediaElement._hoverInterval);
                                     mediaElement._hoverInterval = null;
                                }
                            });
                        } else {
                             console.log("[ApplyHover Enter Video] play() did not return a promise (may indicate immediate success or failure).");
                        }

                        // Optional: Simplified loop check - just rely on loop attribute or pause on leave
                        // Clear previous interval just in case
                        if (mediaElement._hoverInterval) clearInterval(mediaElement._hoverInterval);
                        // We won't use the interval to stop at endTime for simplicity in static export

                    }, 50); // 50ms delay

                } else { // Animated Image
                    console.log("[ApplyHover Enter Img]");
                    const animatedSrc = mediaElement.dataset.animatedSrc || mediaElement.getAttribute('data-animated-src'); // Check both just in case
                    if (animatedSrc) {
                        console.log(`[ApplyHover Enter Img] Switching to animated: ${animatedSrc.substring(0, 50)}...`);
                        mediaElement.src = animatedSrc;
                    } else {
                         console.log("[ApplyHover Enter Img] No animated source found in dataset.");
                    }
                }
            }); // End mouseenter

            shotCard.addEventListener('mouseleave', () => {
                 // Clear any pending play command from mouseenter delay
                 if (hoverTimeout) {
                     clearTimeout(hoverTimeout);
                     hoverTimeout = null;
                 }

                const mediaElement = previewContainer.querySelector('video, img[data-static-src]'); // Check for static src on leave for images
                if (!mediaElement) {
                     //console.log("[ApplyHover Leave] No media element found.");
                     return;
                }

                const isVideo = mediaElement.tagName.toLowerCase() === 'video';

                if (isVideo) {
                     console.log(`[ApplyHover Leave Video] Pausing src: ${mediaElement.currentSrc.substring(0,50)}...`);
                    // Clear interval check if it exists
                    if (mediaElement._hoverInterval) {
                        clearInterval(mediaElement._hoverInterval);
                        mediaElement._hoverInterval = null;
                    }
                    if (!mediaElement.paused) {
                         mediaElement.pause();
                    }
                    // Reset to start time
                    const startTime = parseFloat(mediaElement.dataset.startTime || 0);
                     try {
                          // Check if seeking is possible (readyState > 0)
                          if (mediaElement.readyState > 0) {
                               mediaElement.currentTime = startTime;
                          }
                     } catch (timeError) {
                          console.error("[ApplyHover Leave Video] Error resetting currentTime:", timeError);
                     }
                } else { // Animated Image
                     console.log("[ApplyHover Leave Img]");
                    const staticSrc = mediaElement.dataset.staticSrc || mediaElement.getAttribute('data-static-src');
                    if (staticSrc) {
                         console.log(`[ApplyHover Leave Img] Reverting to static: ${staticSrc.substring(0, 50)}...`);
                        mediaElement.src = staticSrc;
                    } else {
                         console.log("[ApplyHover Leave Img] No static source found in dataset to revert to.");
                    }
                }
            }); // End mouseleave
        }

        // Melhorar a função de edição de vídeo para ser mais responsiva
        function toggleVideoTrimMode(container, video) {
            console.log("Tentando abrir controles de edição", container);
            container.classList.toggle('editing');
            
            if (container.classList.contains('editing')) {
                // Atualizar o UI com valores salvos se existirem
                const startSlider = container.querySelector('.start-time');
                const endSlider = container.querySelector('.end-time');
                const startValue = container.querySelector('.start-value');
                const endValue = container.querySelector('.end-value');
                
                if (!startSlider || !endSlider) {
                    console.error("Sliders não encontrados!");
                    return;
                }
                
                console.log("Preparando controles com duração:", video.duration);
                
                // Certificar-se de que os valores máximos estão corretos
                startSlider.max = video.duration;
                endSlider.max = video.duration;
                
                // Usar valores salvos ou padrões
                if (video.dataset.startTime !== undefined) {
                    startSlider.value = video.dataset.startTime;
                    startValue.textContent = parseFloat(video.dataset.startTime).toFixed(1) + 's';
                } else {
                    startSlider.value = 0;
                    startValue.textContent = '0.0s';
                }
                
                if (video.dataset.endTime !== undefined) {
                    endSlider.value = video.dataset.endTime;
                    endValue.textContent = parseFloat(video.dataset.endTime).toFixed(1) + 's';
                } else {
                    endSlider.value = video.duration;
                    endValue.textContent = video.duration.toFixed(1) + 's';
                }
            }
        }

        // Adicionar aplicação retroativa de eventos para elementos já existentes
        document.addEventListener('DOMContentLoaded', () => {
            // Configuração inicial já existente...
            
            // Aplicar eventos de hover para todos os shots já existentes
            setTimeout(() => {
                console.log("Aplicando eventos de hover e botões de edição para shots existentes");
                document.querySelectorAll('.shot').forEach(shotCard => {
                    const previewContainer = shotCard.querySelector('.shot-preview');
                    if (previewContainer) {
                        const video = previewContainer.querySelector('video');
                        if (video) {
                            // Ensure hover is applied after potential metadata load
                            if(video.readyState >= 1) { // HAVE_METADATA or more
                                applyHoverEvents(shotCard, previewContainer);
                            } else {
                                video.addEventListener('loadedmetadata', () => {
                                     applyHoverEvents(shotCard, previewContainer);
                                }, { once: true });
                            }

                            // Add edit button if missing
                            if (!previewContainer.querySelector('.edit-video-button')) {
                                const editButton = document.createElement('button');
                                editButton.className = 'edit-video-button';
                                editButton.innerHTML = '✂️';
                                editButton.title = 'Editar pontos de entrada/saída';
                                editButton.onclick = (e) => {
                                    e.stopPropagation();
                                    openTrimModal(video);
                                };
                                previewContainer.appendChild(editButton);
                            }
                        } else {
                           // Apply hover for images immediately
                           applyHoverEvents(shotCard, previewContainer);
                        }
                    }
                });
            }, 1000); // Pequeno atraso para garantir que todos os elementos estejam carregados
        });

        // --- NEW: Modal Trimming Logic ---

        function setupModalListeners() {
            modalCloseBtn.onclick = closeTrimModal;
            modalCancelBtn.onclick = closeTrimModal;
            modalApplyBtn.onclick = applyTrimFromModal;
            modalPlayPauseBtn.onclick = toggleModalVideoPlay;
            modalMarkInBtn.onclick = markModalInPoint;
            modalMarkOutBtn.onclick = markModalOutPoint;

            // Update time display on video timeupdate
            modalVideoPlayer.ontimeupdate = updateModalTimeDisplay;

            // Seek video when progress bar is clicked
            modalProgressBarContainer.onclick = (e) => {
                const rect = modalProgressBarContainer.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                const seekTime = modalVideoPlayer.duration * percentage;
                modalVideoPlayer.currentTime = seekTime;
            };

             // Handle video ending
             modalVideoPlayer.onended = () => {
                 modalPlayPauseBtn.textContent = 'Play';
             }

            // Keyboard shortcuts within the modal
            trimModal.addEventListener('keydown', (e) => {
                if (trimModal.style.display !== 'flex') return; // Only when visible

                if (e.key === ' ' || e.key === 'Spacebar') {
                    e.preventDefault();
                    toggleModalVideoPlay();
                } else if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    markModalInPoint();
                } else if (e.key === 'o' || e.key === 'O') {
                    e.preventDefault();
                    markModalOutPoint();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeTrimModal();
                }
            });
        }

        function openTrimModal(originalMediaElement) {
            if (!originalMediaElement) {
                console.error("Tentativa de abrir modal sem elemento de mídia válido.");
                return;
            }
            console.log("Abrindo modal para:", originalMediaElement.src || originalMediaElement.getAttribute('src'));
            
            const isVideo = originalMediaElement.tagName.toLowerCase() === 'video';
            const isAnimatedImage = !isVideo && (
                (originalMediaElement.src && originalMediaElement.src.toLowerCase().includes('.gif')) || 
                (originalMediaElement.src && originalMediaElement.src.toLowerCase().includes('.webp')) ||
                originalMediaElement.dataset.animatedSrc ||
                (originalMediaElement.dataset.fileType && 
                 (originalMediaElement.dataset.fileType.toLowerCase().includes('gif') || 
                  originalMediaElement.dataset.fileType.toLowerCase().includes('webp')))
            );
            
            console.log("Tipo de mídia:", isVideo ? "Vídeo" : (isAnimatedImage ? "Imagem Animada" : "Outro"), 
                       "Tag:", originalMediaElement.tagName, 
                       "FileType:", originalMediaElement.dataset.fileType);
            
            currentEditingVideoElement = originalMediaElement; // Manter referência (mesmo nome de variável para compatibilidade)
            
            // Pausar mídia original se estiver reproduzindo
            if (isVideo) {
                originalMediaElement.pause();
            }
            
            if (isVideo) {
                // Configuração para vídeos (comportamento existente)
                modalVideoPlayer.style.display = 'block';
                if (document.getElementById('modal-gif-container')) {
                    document.getElementById('modal-gif-container').style.display = 'none';
                }
                modalVideoPlayer.src = originalMediaElement.src;
                
                modalVideoPlayer.onloadedmetadata = () => {
                    console.log("Metadados do vídeo do modal carregados. Duração:", modalVideoPlayer.duration);
                    // Get existing trim points from original video dataset or defaults
                    modalStartTime = parseFloat(originalMediaElement.dataset.startTime || 0);
                    modalEndTime = parseFloat(originalMediaElement.dataset.endTime || modalVideoPlayer.duration);
                    
                    // Ensure end time is not beyond actual duration
                    if(modalEndTime > modalVideoPlayer.duration) {
                        modalEndTime = modalVideoPlayer.duration;
                    }
                    // Ensure start time is valid
                    if(modalStartTime < 0 || modalStartTime >= modalEndTime) {
                        modalStartTime = 0;
                    }
                    
                    console.log(`Pontos de trim iniciais: In=${modalStartTime}, Out=${modalEndTime}`);
                    
                    // Set initial state of modal player
                    modalVideoPlayer.currentTime = modalStartTime;
                    modalVideoPlayer.pause();
                    modalPlayPauseBtn.textContent = 'Play';
                    
                    // Update modal UI
                    updateModalTimeDisplay(); // Update current time and progress
                    modalTotalDurationDisplay.textContent = formatTime(modalVideoPlayer.duration);
                    updateModalTrimRangeUI(); // Update visual trim range bar
                    
                    // Garantir que os elementos do modal estejam visíveis
                    document.querySelector('.controls-row').style.display = 'flex';
                    document.querySelector('.modal-action-buttons').style.display = 'flex';
                    
                    // Mostrar o modal
                    trimModal.style.display = 'flex';
                    trimModal.dataset.isGif = 'false';
                    trimModal.focus(); // Permitir atalhos de teclado
                };
                
                modalVideoPlayer.onerror = (e) => {
                    console.error("Erro ao carregar vídeo no modal:", e);
                    showStatus("Erro ao carregar vídeo para edição.", 4000);
                    closeTrimModal();
                };
            } 
            else if (isAnimatedImage) {
                // Configuração para GIFs e WebPs animados
                console.log("Preparando modal para imagem animada:", originalMediaElement);
                modalVideoPlayer.style.display = 'none'; // Esconder o player de vídeo
                
                // Criar ou atualizar um SuperGif para o GIF
                let gifContainer = document.getElementById('modal-gif-container');
                if (!gifContainer) {
                    gifContainer = document.createElement('div');
                    gifContainer.id = 'modal-gif-container';
                    gifContainer.style.width = '100%';
                    gifContainer.style.height = '100%';
                    gifContainer.style.display = 'flex';
                    gifContainer.style.justifyContent = 'center';
                    gifContainer.style.alignItems = 'center';
                    gifContainer.style.backgroundColor = '#000';
                    gifContainer.style.position = 'relative';
                    document.getElementById('modal-video-container').appendChild(gifContainer);
                } else {
                    gifContainer.innerHTML = ''; // Limpar conteúdo anterior
                    gifContainer.style.display = 'flex'; // Garantir que esteja visível
                }
                
                // Criar um elemento de imagem para o SuperGif
                const img = document.createElement('img');
                img.id = 'modal-gif-player';
                img.style.maxWidth = '100%';
                img.style.maxHeight = '100%';
                
                // Usar src animado se disponível, senão usar src normal
                const imgSrc = originalMediaElement.dataset.animatedSrc || originalMediaElement.src;
                console.log("Usando src para a imagem animada no modal:", imgSrc.substring(0, 50) + "...", 
                          "FileType:", originalMediaElement.dataset.fileType);
                img.src = imgSrc;
                
                gifContainer.appendChild(img);
                
                try {
                    // Criar SuperGif para controle de frames
                    let gif = new SuperGif({ 
                        gif: img,
                        auto_play: false,
                        loop_mode: false,
                        draw_while_loading: true,
                        show_progress_bar: true 
                    });
                    
                    gif.load(function() {
                        console.log("Imagem animada carregada. Total de frames:", gif.get_length());
                        
                        // Obter pontos de trim existentes ou definir padrões
                        const totalFrames = gif.get_length();
                        let startFrame = parseInt(originalMediaElement.dataset.startFrame || 0);
                        let endFrame = parseInt(originalMediaElement.dataset.endFrame || (totalFrames - 1));
                        
                        // Garantir que os valores são válidos
                        if (startFrame < 0 || startFrame >= totalFrames) startFrame = 0;
                        if (endFrame >= totalFrames || endFrame <= startFrame) endFrame = totalFrames - 1;
                        
                        // Converter frames para valores normalizados (0-100) para interface
                        modalStartTime = startFrame;
                        modalEndTime = endFrame;
                        
                        console.log(`GIF pontos de trim: Start=${startFrame}, End=${endFrame}, Total=${totalFrames}`);
                        
                        // Definir o primeiro frame
                        gif.move_to(startFrame);
                        
                        // Atualizar UI do modal
                        modalCurrentTimeDisplay.textContent = `Frame ${startFrame}`;
                        modalTotalDurationDisplay.textContent = `${totalFrames} frames`;
                        
                        // Guardar total de frames para calcular porcentagens
                        trimModal.dataset.totalFrames = totalFrames;
                        trimModal.dataset.isGif = 'true';
                        
                        // Garantir que os elementos do modal estejam visíveis
                        document.querySelector('.controls-row').style.display = 'flex';
                        document.querySelector('.modal-action-buttons').style.display = 'flex';
                        
                        // Atualizar visual da barra de progresso
                        updateModalTrimRangeUI();
                        
                        // Mostrar o modal
                        trimModal.style.display = 'flex';
                        trimModal.focus();
                        
                        // Armazenar a referência do gif para uso em outras funções
                        window.currentGif = gif;
                    });
                    
                    // Tratar erros básicos de carregamento da imagem
                    img.onerror = function() {
                        console.error("Erro ao carregar imagem animada");
                        showStatus("Erro ao carregar imagem animada", 3000);
                        closeTrimModal();
                    };
                } catch (error) {
                    console.error("Erro ao inicializar SuperGif:", error);
                    showStatus("Erro ao processar imagem animada", 3000);
                    closeTrimModal();
                }
            }
            else {
                console.error("Elemento não suportado para trimming:", originalMediaElement);
                showStatus("Tipo de mídia não suportado para edição de pontos.", 3000);
                return;
            }
        }

        function closeTrimModal() {
            // Parar vídeo, se estiver sendo usado
            modalVideoPlayer.pause();
            modalVideoPlayer.src = ''; 
            
            // Limpar referência ao GIF, se estiver sendo usado
            window.currentGif = null;
            
            // Esconder o modal
            trimModal.style.display = 'none';
            
            // Limpar dataset que especifica tipo
            delete trimModal.dataset.isGif;
            
            // Limpar referência ao elemento original
            currentEditingVideoElement = null;
        }

        function applyTrimFromModal() {
            if (!currentEditingVideoElement) {
                console.error("Erro: applyTrimFromModal chamado sem currentEditingVideoElement.");
                closeTrimModal();
                return;
            }
            
            const isGif = trimModal.dataset.isGif === 'true';
            
            if (isGif) {
                // Aplicar trim para GIFs/WebPs
                const totalFrames = parseInt(trimModal.dataset.totalFrames);
                if (!totalFrames) {
                    console.error("Erro: totalFrames não definido para GIF");
                    closeTrimModal();
                    return;
                }
                
                // Validar frames uma última vez
                let startFrame = modalStartTime;
                let endFrame = modalEndTime;
                
                if (startFrame < 0) startFrame = 0;
                if (endFrame >= totalFrames) endFrame = totalFrames - 1;
                if (startFrame >= endFrame) {
                    startFrame = 0;
                    endFrame = totalFrames - 1;
                    showStatus("Frames de início/fim inválidos, resetando.", 3000);
                }
                
                console.log(`Aplicando trim ao GIF: Start=${startFrame}, End=${endFrame}`);
                
                // Armazenar pontos como frames
                currentEditingVideoElement.dataset.startFrame = startFrame;
                currentEditingVideoElement.dataset.endFrame = endFrame;
                
                // Para compatibilidade com reprodução ao passar o mouse
                // também armazenar como pontos normalizados (0-1)
                currentEditingVideoElement.dataset.startTime = (startFrame / totalFrames).toFixed(4);
                currentEditingVideoElement.dataset.endTime = (endFrame / totalFrames).toFixed(4);
            } 
            else {
                // Aplicar trim para vídeos (código existente)
                if (modalStartTime < 0) modalStartTime = 0;
                if (modalEndTime > modalVideoPlayer.duration) modalEndTime = modalVideoPlayer.duration;
                if (modalStartTime >= modalEndTime) {
                    modalStartTime = 0;
                    modalEndTime = modalVideoPlayer.duration;
                    showStatus("Pontos de In/Out inválidos, resetando.", 3000);
                }
                
                console.log(`Aplicando trim: In=${modalStartTime}, Out=${modalEndTime}`);
                currentEditingVideoElement.dataset.startTime = modalStartTime.toFixed(4);
                currentEditingVideoElement.dataset.endTime = modalEndTime.toFixed(4);
                
                // Atualizar thumbnail para o início
                currentEditingVideoElement.currentTime = modalStartTime;
            }
            
            showStatus("Pontos de In/Out aplicados!", 1500);
            closeTrimModal();
        }

        function toggleModalVideoPlay() {
            const isGif = trimModal.dataset.isGif === 'true';
            
            if (isGif && window.currentGif) {
                // Reproduzir/pausar GIF
                if (window.gifPlaying) {
                    // Pausar
                    if (window._gifInterval) {
                        clearInterval(window._gifInterval);
                        window._gifInterval = null;
                    }
                    window.gifPlaying = false;
                    modalPlayPauseBtn.textContent = 'Play';
                } else {
                    // Reproduzir
                    const gif = window.currentGif;
                    const startFrame = modalStartTime;
                    const endFrame = modalEndTime;
                    
                    // Garantir que estamos no frame inicial
                    if (gif.get_current_frame() < startFrame || gif.get_current_frame() > endFrame) {
                        gif.move_to(startFrame);
                    }
                    
                    // Iniciar intervalo para avançar frames
                    window._gifInterval = setInterval(() => {
                        const currentFrame = gif.get_current_frame();
                        
                        if (currentFrame >= endFrame) {
                            // Chegou ao fim, parar e voltar ao início
                            clearInterval(window._gifInterval);
                            window._gifInterval = null;
                            window.gifPlaying = false;
                            modalPlayPauseBtn.textContent = 'Play';
                            gif.move_to(startFrame);
                        } else {
                            // Avançar para o próximo frame
                            gif.move_relative(1);
                            updateModalGifTimeDisplay();
                        }
                    }, 100); // Aproximadamente 10fps
                    
                    window.gifPlaying = true;
                    modalPlayPauseBtn.textContent = 'Pause';
                }
            } else {
                // Código existente para vídeos
                if (modalVideoPlayer.paused || modalVideoPlayer.ended) {
                    // Garantir reprodução dentro dos limites definidos
                    if (modalVideoPlayer.currentTime < modalStartTime || modalVideoPlayer.currentTime >= modalEndTime) {
                        modalVideoPlayer.currentTime = modalStartTime;
                    }
                    modalVideoPlayer.play();
                    modalPlayPauseBtn.textContent = 'Pause';
                } else {
                    modalVideoPlayer.pause();
                    modalPlayPauseBtn.textContent = 'Play';
                }
            }
        }

        function markModalInPoint() {
            const isGif = trimModal.dataset.isGif === 'true';
            
            if (isGif && window.currentGif) {
                // Marcar frame inicial
                modalStartTime = window.currentGif.get_current_frame();
                
                // Verificar se o frame inicial está após o frame final
                if (modalStartTime >= modalEndTime) {
                    modalStartTime = modalEndTime - 1;
                    if (modalStartTime < 0) modalStartTime = 0;
                    window.currentGif.move_to(modalStartTime);
                }
                
                console.log("GIF: Marcado frame inicial:", modalStartTime);
                updateModalGifTimeDisplay();
            } else {
                // Código existente para vídeos
                modalStartTime = modalVideoPlayer.currentTime;
                // Verificar se o ponto inicial não está após o ponto final
                if (modalStartTime >= modalEndTime) {
                    modalStartTime = modalEndTime - 0.1;
                    if (modalStartTime < 0) modalStartTime = 0;
                    modalVideoPlayer.currentTime = modalStartTime;
                }
                console.log("Marcado In:", modalStartTime);
            }
            
            updateModalTrimRangeUI();
        }

        function markModalOutPoint() {
            const isGif = trimModal.dataset.isGif === 'true';
            
            if (isGif && window.currentGif) {
                // Marcar frame final
                modalEndTime = window.currentGif.get_current_frame();
                
                // Verificar se o frame final está antes do frame inicial
                if (modalEndTime <= modalStartTime) {
                    modalEndTime = modalStartTime + 1;
                    const totalFrames = parseInt(trimModal.dataset.totalFrames || window.currentGif.get_length());
                    if (modalEndTime >= totalFrames) modalEndTime = totalFrames - 1;
                    window.currentGif.move_to(modalEndTime);
                }
                
                console.log("GIF: Marcado frame final:", modalEndTime);
                updateModalGifTimeDisplay();
            } else {
                // Código existente para vídeos
                modalEndTime = modalVideoPlayer.currentTime;
                // Verificar se o ponto final não está antes do ponto inicial
                if (modalEndTime <= modalStartTime) {
                    modalEndTime = modalStartTime + 0.1;
                    if (modalEndTime > modalVideoPlayer.duration) modalEndTime = modalVideoPlayer.duration;
                    modalVideoPlayer.currentTime = modalEndTime;
                }
                console.log("Marcado Out:", modalEndTime);
            }
            
            updateModalTrimRangeUI();
        }

        function updateModalTimeDisplay() {
            if (!modalVideoPlayer.duration) return;
            
            const currentTime = modalVideoPlayer.currentTime;
            const duration = modalVideoPlayer.duration;
            
            // Atualizar texto
            modalCurrentTimeDisplay.textContent = formatTime(currentTime);
            
            // Atualizar marcador na barra de progresso
            const markerPercent = (currentTime / duration) * 100;
            modalProgressMarker.style.left = `${markerPercent}%`;
            
            // Atualizar barra de progresso reproduzido
            modalProgressPlayed.style.width = `${markerPercent}%`;
            
            // Verificar se atingiu o ponto final durante reprodução
            if (!modalVideoPlayer.paused && currentTime >= modalEndTime) {
                modalVideoPlayer.pause();
                modalVideoPlayer.currentTime = modalEndTime;
                modalPlayPauseBtn.textContent = 'Play';
            }
        }

        function updateModalGifTimeDisplay() {
            if (!window.currentGif) return;
            
            const currentFrame = window.currentGif.get_current_frame();
            const totalFrames = parseInt(trimModal.dataset.totalFrames || window.currentGif.get_length());
            
            // Atualizar texto
            modalCurrentTimeDisplay.textContent = `Frame ${currentFrame}`;
            
            // Atualizar marcador na barra de progresso
            const markerPercent = (currentFrame / (totalFrames - 1)) * 100;
            modalProgressMarker.style.left = `${markerPercent}%`;
            
            // Atualizar barra de progresso
            modalProgressPlayed.style.width = `${markerPercent}%`;
        }

        function updateModalTrimRangeUI() {
            const isGif = trimModal.dataset.isGif === 'true';
            
            if (isGif) {
                // Atualizar visualização para GIFs
                const totalFrames = parseInt(trimModal.dataset.totalFrames || (window.currentGif ? window.currentGif.get_length() : 100));
                if (!totalFrames) return;
                
                const startPercent = (modalStartTime / (totalFrames - 1)) * 100;
                const endPercent = (modalEndTime / (totalFrames - 1)) * 100;
                const widthPercent = endPercent - startPercent;
                
                modalProgressTrimRange.style.left = `${startPercent}%`;
                modalProgressTrimRange.style.width = `${widthPercent}%`;
                
                // Destacar botões se pontos estiverem definidos
                modalMarkInBtn.style.fontWeight = modalStartTime > 0 ? 'bold' : 'normal';
                modalMarkOutBtn.style.fontWeight = modalEndTime < (totalFrames - 1) ? 'bold' : 'normal';
            } else {
                // Código existente para vídeos
                if (!modalVideoPlayer.duration) return;
                
                const duration = modalVideoPlayer.duration;
                const startPercent = (modalStartTime / duration) * 100;
                const endPercent = (modalEndTime / duration) * 100;
                const widthPercent = endPercent - startPercent;
                
                modalProgressTrimRange.style.left = `${startPercent}%`;
                modalProgressTrimRange.style.width = `${widthPercent}%`;
                
                // Destacar botões se pontos estiverem definidos
                modalMarkInBtn.style.fontWeight = modalStartTime > 0 ? 'bold' : 'normal';
                modalMarkOutBtn.style.fontWeight = modalEndTime < duration ? 'bold' : 'normal';
            }
        }

        // Adicionar a função readFileAsBase64 se ainda não existir
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }

        // Função para extrair o primeiro frame de um GIF/WebP animado
        function createStaticImageFromAnimated(file) {
            return new Promise((resolve, reject) => {
                try {
                    // Criar uma URL para o arquivo de imagem
                    const objectURL = URL.createObjectURL(file);
                    
                    // Criar elementos para processamento
                    const img = document.createElement('img');
                    img.onload = () => {
                        try {
                            // Criar canvas para desenhar o primeiro frame
                            const canvas = document.createElement('canvas');
                            canvas.width = img.naturalWidth;
                            canvas.height = img.naturalHeight;
                            
                            // Desenhar a imagem no canvas (apenas o primeiro frame)
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            
                            // Converter para Data URL
                            const staticDataURL = canvas.toDataURL('image/png');
                            
                            // Limpar recursos
                            URL.revokeObjectURL(objectURL);
                            
                            resolve(staticDataURL);
                        } catch (error) {
                            console.error("Erro ao criar thumbnail estático:", error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        URL.revokeObjectURL(objectURL);
                        reject(new Error('Falha ao carregar imagem para processamento'));
                    };
                    
                    // Definir a fonte da imagem para iniciar o carregamento
                    img.src = objectURL;
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Função para ler um arquivo como Base64
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                try {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Torna função addScene disponível globalmente
        window.addScene = function(sceneData) {
            let sceneEl;
            if (sceneData) {
                sceneEl = createSceneElement(sceneData.title);
                const sceneDescTextarea = sceneEl.querySelector('[data-scene-desc]');
                if (sceneDescTextarea && sceneData.description) {
                    sceneDescTextarea.value = sceneData.description;
                    autoResize(sceneDescTextarea);
                }
                
                // Add shots if they exist
                if (Array.isArray(sceneData.shots)) {
                    sceneData.shots.forEach(shot => {
                        const shotEl = createShotElement(sceneEl, shot.title);
                        const shotDescTextarea = shotEl.querySelector('[data-shot-desc]');
                        if (shotDescTextarea && shot.description) {
                            shotDescTextarea.value = shot.description;
                            autoResize(shotDescTextarea);
                        }
                    });
                }
            } else {
                // Create empty scene
                sceneEl = createSceneElement();
            }
            
            // Add scene to the container
            scenesContainer.appendChild(sceneEl);
            return sceneEl;
        };

        // ... existing code ...
        // Definition of applyHoverEvents (copied from original scope, use the V3 version with logging)
        function applyHoverEvents_injected(shotCard, previewContainer) {
            if (!shotCard) return;
            
            shotCard.addEventListener('mouseenter', () => {
                // Seleciona vídeo OU imagem que seja animada (gif/webp)
                const mediaElement = previewContainer.querySelector('video, img[data-static-src], img[data-animatedSrc], img[data-animated-src]');
                if (!mediaElement) return;
                
                if (mediaElement.tagName.toLowerCase() === 'video') {
                    console.log("Hover - É vídeo, tentando tocar...");
                    
                    // Ensure video is muted for autoplay
                    mediaElement.muted = true;
                    mediaElement.setAttribute('playsinline', '');
                    
                    // Use dataset values set by modal (or defaults)
                    const startTime = parseFloat(mediaElement.dataset.startTime || 0);
                    let endTime = parseFloat(mediaElement.dataset.endTime);
                    // If endTime is not set or invalid, use duration
                    if (isNaN(endTime) || endTime <= startTime) {
                        endTime = mediaElement.duration || 999; // Use a large number if duration is not available yet
                    }

                    // Set starting point
                    mediaElement.currentTime = startTime;
                    console.log("Hover play from " + startTime + " to " + endTime);

                    // Clear any previous interval
                    if (mediaElement._hoverInterval) {
                        clearInterval(mediaElement._hoverInterval);
                        mediaElement._hoverInterval = null;
                    }

                    // Garantindo que o vídeo esteja pronto para ser reproduzido
                    if (mediaElement.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                        mediaElement.play().catch(e => console.log("Erro ao reproduzir vídeo:", e));
                    } else {
                        // Se o vídeo não estiver pronto, aguarde o evento canplay
                        mediaElement.addEventListener('canplay', function onCanPlay() {
                            mediaElement.play().catch(e => console.log("Erro ao reproduzir vídeo (canplay):", e));
                            mediaElement.removeEventListener('canplay', onCanPlay);
                        });
                        
                        // Como backup, tentar reproduzir após um curto período
                        setTimeout(() => {
                            mediaElement.play().catch(e => console.log("Erro ao reproduzir vídeo (timeout):", e));
                        }, 100);
                    }

                    // Add an interval check to stop at endTime
                    mediaElement._hoverInterval = setInterval(() => {
                        // Se o vídeo estiver reproduzindo, verifique se chegou ao final
                        if (!mediaElement.paused && mediaElement.currentTime >= endTime) {
                            mediaElement.pause();
                            mediaElement.currentTime = startTime; // Reset to start
                            clearInterval(mediaElement._hoverInterval);
                            mediaElement._hoverInterval = null;
                        }
                    }, 50); // Check frequently
                } 
                else if (mediaElement.dataset.animatedSrc || 
                         mediaElement.getAttribute('data-animated-src') || 
                         mediaElement.src?.endsWith('.gif') || 
                         mediaElement.src?.endsWith('.webp')) {
                    console.log("Hover - É imagem animada...");
                    
                    // Trocar para versão animada - testar ambos os formatos de atributo
                    const animatedSrc = mediaElement.dataset.animatedSrc || mediaElement.getAttribute('data-animated-src');
                    if (animatedSrc) {
                        console.log("Usando versão animada:", animatedSrc.substring(0, 50)+"...");
                        mediaElement.src = animatedSrc;
                    }
                }
            });
            
            shotCard.addEventListener('mouseleave', () => {
                const mediaElement = previewContainer.querySelector('video, img[data-static-src], img[data-animatedSrc], img[data-animated-src]');
                if (!mediaElement) return;
                
                if (mediaElement.tagName.toLowerCase() === 'video') {
                    // Clear interval check on mouse leave
                    if (mediaElement._hoverInterval) {
                        clearInterval(mediaElement._hoverInterval);
                        mediaElement._hoverInterval = null;
                    }
                    mediaElement.pause();
                    // Voltar ao ponto inicial definido ou 0
                    const startTime = parseFloat(mediaElement.dataset.startTime || 0);
                    mediaElement.currentTime = startTime;
                } 
                else {
                    // Voltar para versão estática - testar ambos os formatos
                    const staticSrc = mediaElement.dataset.staticSrc || mediaElement.getAttribute('data-static-src');
                    if (staticSrc) {
                        console.log("Revertendo para versão estática:", staticSrc.substring(0, 50)+"...");
                        mediaElement.src = staticSrc;
                    }
                }
            });
        } // Rename to avoid conflict if somehow global exists

        // <<< NOVA FUNÇÃO para Drag & Drop dos Shots >>>
        function setupShotDragDropListeners() {
            scenesContainer.addEventListener('dragstart', (e) => {
                // Verificamos se o alvo é o handle ou o shot inteiro
                if (e.target.classList.contains('drag-handle') || e.target.classList.contains('shot')) {
                    // Encontrar o elemento shot mais próximo (pai ou o próprio)
                    draggedShot = e.target.closest('.shot');
                    if (!draggedShot) return;

                    // Usar ID do shot para transferência
                    e.dataTransfer.setData('text/plain', draggedShot.dataset.shotId);
                    e.dataTransfer.effectAllowed = 'move';
                    
                    // Adicionar classe para feedback visual
                    setTimeout(() => {
                         if(draggedShot) draggedShot.classList.add('dragging');
                    }, 0);
                    console.log('Drag Start:', draggedShot.dataset.shotId);
                } else {
                    console.log('Drag tentado em um elemento que não é o handle nem o shot:', e.target);
                    // Se não começou no handle ou no shot, impedir o drag
                    if (!e.target.closest('.shot-preview')) {
                        console.log('Impedindo drag fora do handle/shot');
                        e.preventDefault();
                        return false;
                    }
                }
            });

            scenesContainer.addEventListener('dragend', (e) => {
                if (draggedShot) {
                    console.log('Drag End');
                    draggedShot.classList.remove('dragging');
                    // Limpar qualquer indicador de drop residual
                    document.querySelectorAll('.shot.drag-over-shot').forEach(el => el.classList.remove('drag-over-shot'));
                    draggedShot = null;
                }
            });

            scenesContainer.addEventListener('dragover', (e) => {
                if (!draggedShot) return; // Só processar se um shot estiver sendo arrastado

                const targetShot = e.target.closest('.shot');
                if (!targetShot || targetShot === draggedShot) return; // Não fazer nada se for o próprio shot ou fora de um shot válido
                
                e.preventDefault(); // Permitir o drop
                e.dataTransfer.dropEffect = 'move';

                // Adicionar classe de feedback ao shot alvo
                targetShot.classList.add('drag-over-shot');
            });

            scenesContainer.addEventListener('dragleave', (e) => {
                if (!draggedShot) return;

                const targetShot = e.target.closest('.shot');
                if (targetShot) {
                    targetShot.classList.remove('drag-over-shot');
                }
            });

            scenesContainer.addEventListener('drop', (e) => {
                if (!draggedShot) return; // Só processar drop se for de um shot

                e.preventDefault();
                const targetShot = e.target.closest('.shot');
                
                // Limpar feedback visual do alvo
                if(targetShot) targetShot.classList.remove('drag-over-shot');

                if (!targetShot || targetShot === draggedShot) {
                    // Se soltar fora de um shot válido ou sobre si mesmo, não faz nada
                    // dragend vai limpar o estado
                    return;
                }

                console.log('Drop on:', targetShot.dataset.shotId, 'From:', draggedShot.dataset.shotId);

                // Lógica de Inserção Simples: Inserir antes do shot alvo
                const shotsContainer = targetShot.parentNode;
                // Obter todos os shots atuais na ordem
                const allShots = Array.from(shotsContainer.querySelectorAll('.shot'));
                const targetIndex = allShots.indexOf(targetShot);
                const draggedIndex = allShots.indexOf(draggedShot);
                
                console.log(`Moving from index ${draggedIndex} to before index ${targetIndex}`);

                if (targetIndex > -1) {
                    // Determinar posição relativa para inserção mais inteligente
                    const rect = targetShot.getBoundingClientRect();
                    const halfwayX = rect.left + rect.width / 2; // Usar lógica horizontal
                    
                    if (e.clientX < halfwayX) {
                        // Inserir ANTES do targetShot
                        shotsContainer.insertBefore(draggedShot, targetShot);
                        console.log('Inserted BEFORE target (left side)');
                    } else {
                        // Inserir DEPOIS do targetShot
                        shotsContainer.insertBefore(draggedShot, targetShot.nextSibling);
                        console.log('Inserted AFTER target (right side)');
                    }
                }
                // dragend vai limpar a classe dragging e a variável draggedShot
            });
        }

        // Função para resetar o storyboard
        function resetStoryboard() {
            if (window.confirm('Tem certeza que deseja resetar o storyboard? Todas as cenas e configurações serão perdidas.')) {
                // Resetar as cenas
                const scenesContainer = document.querySelector('.scenes-container');
                scenesContainer.innerHTML = '';
                
                // Adicionar primeira cena vazia
                addScene();
                
                // Resetar configurações para o padrão
                settings = {
                    theme: 'dark',
                    cardBackground: '#282828',
                    cardBorderStyle: '1px solid #3a3a3a',
                    descriptionBackground: '#222222',
                    descriptionBorderStyle: '1px solid #3a3a3a',
                    previewBackground: '#404040',
                    previewBorderStyle: 'none',
                    shotAspectRatio: '16/9',
                    shotPadding: '1rem',
                    shotGap: '1.5rem',
                    showShotTitles: true
                };
                
                // Resetar informações do projeto
                projectInfo = {
                    movieName: 'Nome do Filme',
                    clientName: 'Cliente',
                    logoDataUrl: null,
                    movieTitleColor: '#00a650',
                    movieFontSize: '32',
                    clientNameColor: '#EAEAEA',
                    clientFontSize: '18',
                    textSpacing: '12'
                };
                
                // Limpar localStorage para remover dados salvos
                localStorage.removeItem('storyboardData');
                localStorage.removeItem('storyboardSettings');
                localStorage.removeItem('storyboardProjectInfo');
                
                // Atualizar UI
                updateThemeUI();
                updateProjectInfoUI();
                
                // Limpar referências de arquivos
                fileReferences = {};
                
                // Notificar o usuário
                showStatus('Storyboard resetado com sucesso!', 2000);
            }
        }

        // Adicionar event listener para o botão de reset
        document.getElementById('resetButton').addEventListener('click', resetStoryboard);

        // Adicionar event listener para o botão de configurações
        document.getElementById('settingsButton').addEventListener('click', toggleSettingsPanel);

        // Adicionar event listener para o botão de salvar
        document.getElementById('saveButton').addEventListener('click', toggleDropdown);
    </script>
</body>
</html>

