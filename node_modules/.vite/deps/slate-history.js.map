{
  "version": 3,
  "sources": ["../../slate-history/src/history.ts", "../../slate-history/src/history-editor.ts", "../../slate-history/src/with-history.ts"],
  "sourcesContent": ["import { isPlainObject } from 'is-plain-object'\nimport { Operation, Range } from 'slate'\n\ninterface Batch {\n  operations: Operation[]\n  selectionBefore: Range | null\n}\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Batch[]\n  undos: Batch[]\n}\n\n// eslint-disable-next-line no-redeclare\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 ||\n        Operation.isOperationList(value.redos[0].operations)) &&\n      (value.undos.length === 0 ||\n        Operation.isOperationList(value.undos[0].operations))\n    )\n  },\n}\n", "import { BaseEditor, Editor } from 'slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends BaseEditor {\n  history: History\n  undo: () => void\n  redo: () => void\n  writeHistory: (stack: 'undos' | 'redos', batch: any) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return History.isHistory(value.history) && Editor.isEditor(value)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Redo to the previous saved state.\n   */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo()\n  },\n\n  /**\n   * Undo to the previous saved state.\n   */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo()\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    fn()\n    SAVING.set(editor, prev)\n  },\n}\n", "import { Editor, Operation, Path, Range, Transforms } from 'slate'\n\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor\n  const { apply } = e\n  e.history = { undos: [], redos: [] }\n\n  e.redo = () => {\n    const { history } = e\n    const { redos } = history\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1]\n\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore)\n      }\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch.operations) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.pop()\n      e.writeHistory('undos', batch)\n    }\n  }\n\n  e.undo = () => {\n    const { history } = e\n    const { undos } = history\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.operations.map(Operation.inverse).reverse()\n\n          for (const op of inverseOps) {\n            e.apply(op)\n          }\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore)\n          }\n        })\n      })\n\n      e.writeHistory('redos', batch)\n      history.undos.pop()\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e\n    const { undos } = history\n    const lastBatch = undos[undos.length - 1]\n    const lastOp =\n      lastBatch && lastBatch.operations[lastBatch.operations.length - 1]\n    let save = HistoryEditor.isSaving(e)\n    let merge = HistoryEditor.isMerging(e)\n\n    if (save == null) {\n      save = shouldSave(op, lastOp)\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false\n        } else if (operations.length !== 0) {\n          merge = true\n        } else {\n          merge = shouldMerge(op, lastOp)\n        }\n      }\n\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op)\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        }\n        e.writeHistory('undos', batch)\n      }\n\n      while (undos.length > 100) {\n        undos.shift()\n      }\n\n      history.redos = []\n    }\n\n    apply(op)\n  }\n\n  e.writeHistory = (stack: 'undos' | 'redos', batch: any) => {\n    e.history[stack].push(batch)\n  }\n\n  return e\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n"],
  "mappings": "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",
  "names": ["History", "isHistory", "value", "isPlainObject", "Array", "isArray", "redos", "undos", "length", "Operation", "isOperationList", "operations", "HISTORY", "WeakMap", "SAVING", "MERGING", "HistoryEditor", "isHistoryEditor", "history", "Editor", "isEditor", "isMerging", "editor", "get", "isSaving", "redo", "undo", "withoutMerging", "fn", "prev", "set", "withoutSaving", "withHistory", "e", "apply", "batch", "selectionBefore", "Transforms", "setSelection", "withoutNormalizing", "op", "pop", "writeHistory", "inverseOps", "map", "inverse", "reverse", "lastBatch", "lastOp", "save", "merge", "shouldSave", "shouldMerge", "push", "selection", "shift", "stack", "type", "offset", "text", "Path", "equals", "path"]
}
